steps=c(0.1,0.1))
f_create <- function(parTab, data, PRIOR_FUNC, ...){
f <- function(pars){
names(pars) <- parTab$names
lik <- dbinom(x=data, size=pars["n"],p=pars["p"],log=TRUE)
return(lik)
}
}
post <- f_create(parTab, data, NULL)
post(c(13/16,16))
mcmcPars <- c("iterations"=10000,"popt"=0.44,"opt_freq"=1000,
"thin"=1,"adaptive_period"=5000,"save_block"=100)
## The MCMC code uses the parameter table. Here, we should specify some random starting
## points in the "values" column.
startTab <- parTab
startTab$values <- c(3.5,1)
## You could have done something like this:
## startTab$values <- runif(nrow(startTab), startTab$lower_bound, startTab$upper_bound)
output <- run_MCMC(parTab=startTab, data=data, mcmcPars=mcmcPars, filename="test",
CREATE_POSTERIOR_FUNC=f_create, mvrPars=NULL,
PRIOR_FUNC = my_prior, OPT_TUNING=0.2)
library(lazymcmc)
data <- 13
parTab <- data.frame(values=c(0.5,16),
names=c("p","n"),
fixed=c(0,1),
lower_bound=c(-Inf,-Inf),
upper_bound=c(Inf,Inf),
steps=c(0.1,0.1))
f_create <- function(parTab, data, PRIOR_FUNC, ...){
f <- function(pars){
names(pars) <- parTab$names
lik <- dbinom(x=data, size=pars["n"],p=pars["p"],log=TRUE)
return(lik)
}
}
post <- f_create(parTab, data, NULL)
post(c(13/16,16))
mcmcPars <- c("iterations"=10000,"popt"=0.44,"opt_freq"=1000,
"thin"=1,"adaptive_period"=5000,"save_block"=100)
## The MCMC code uses the parameter table. Here, we should specify some random starting
## points in the "values" column.
startTab <- parTab
## You could have done something like this:
## startTab$values <- runif(nrow(startTab), startTab$lower_bound, startTab$upper_bound)
output <- run_MCMC(parTab=startTab, data=data, mcmcPars=mcmcPars, filename="test",
CREATE_POSTERIOR_FUNC=f_create, mvrPars=NULL,
PRIOR_FUNC = my_prior, OPT_TUNING=0.2)
startTab
mcmcpars
mcmcPars
library(lazymcmc)
data <- 13
parTab <- data.frame(values=c(0.5,16),
names=c("p","n"),
fixed=c(0,1),
lower_bound=c(-Inf,-Inf),
upper_bound=c(Inf,Inf),
steps=c(0.1,0.1))
f_create <- function(parTab, data, PRIOR_FUNC, ...){
f <- function(pars){
names(pars) <- parTab$names
lik <- dbinom(x=data, size=pars["n"],p=pars["p"],log=TRUE)
return(lik)
}
}
post <- f_create(parTab, data, NULL)
post(c(13/16,16))
mcmcPars <- c("iterations"=10000,"popt"=0.44,"opt_freq"=1000,
"thin"=1,"adaptive_period"=5000,"save_block"=100)
## The MCMC code uses the parameter table. Here, we should specify some random starting
## points in the "values" column.
startTab <- parTab
## You could have done something like this:
## startTab$values <- runif(nrow(startTab), startTab$lower_bound, startTab$upper_bound)
output <- run_MCMC(parTab=startTab, data=data, mcmcPars=mcmcPars, filename="test",
CREATE_POSTERIOR_FUNC=f_create, mvrPars=NULL,
PRIOR_FUNC = NULL, OPT_TUNING=0.2)
post(startTab$values)
data
startTab
library(lazymcmc)
data <- 13
parTab <- data.frame(values=c(0.5,16),
names=c("p","n"),
fixed=c(0,1),
lower_bound=c(-Inf,-Inf),
upper_bound=c(Inf,Inf),
steps=c(0.01,0.1))
f_create <- function(parTab, data, PRIOR_FUNC, ...){
f <- function(pars){
names(pars) <- parTab$names
lik <- dbinom(x=data, size=pars["n"],p=pars["p"],log=TRUE)
return(lik)
}
}
post <- f_create(parTab, data, NULL)
post(c(13/16,16))
mcmcPars <- c("iterations"=10000,"popt"=0.44,"opt_freq"=1000,
"thin"=1,"adaptive_period"=5000,"save_block"=100)
## The MCMC code uses the parameter table. Here, we should specify some random starting
## points in the "values" column.
startTab <- parTab
## You could have done something like this:
## startTab$values <- runif(nrow(startTab), startTab$lower_bound, startTab$upper_bound)
output <- run_MCMC(parTab=startTab, data=data, mcmcPars=mcmcPars, filename="test",
CREATE_POSTERIOR_FUNC=f_create, mvrPars=NULL,
PRIOR_FUNC = NULL, OPT_TUNING=0.2)
data
mean <- 5
sd <- 2
data <- rnorm(10000, mean=mean, sd=sd)
parTab <- data.frame(values=c(5,2),
names=c("mu","sd"),
fixed=0,
lower_bound=c(-Inf,-Inf),
upper_bound=c(Inf,Inf),
steps=c(0.1,0.1))
my_creation_function <- function(parTab, data, PRIOR_FUNC, ...){
##############################
## This is where you would manipulate all
## of your model arguments. For example,
## unpackaging the stuff from `...`,
## or transforming model parameters
##############################
## Somewhat redundant example
parameter_names <- parTab$names
##############################
## This is where you would put your own model code
##############################
f <- function(pars){
names(pars) <- names
mu <- pars["mu"]
sd <- pars["sd"]
## Note the use of closures to capture the `data` argument
lik <- sum(dnorm(data, mu, sd, TRUE))
if(!is.null(PRIOR_FUNC)) lik <- lik + PRIOR_FUNC(pars)
lik
}
return(f)
}
## Note that we've given it a prior function too. lazymcmc will
## combine this function pointer with the likelihood function.
my_prior <- function(pars){
a <- dnorm(pars["mu"],5,10,1)
b <- dnorm(pars["sd"],2,10,1)
return(a + b)
}
## To test that it's working
posterior <- my_creation_function(parTab, data, my_prior)
print(posterior(parTab$values))
mcmcPars <- c("iterations"=10000,"popt"=0.44,"opt_freq"=1000,
"thin"=1,"adaptive_period"=5000,"save_block"=100)
## The MCMC code uses the parameter table. Here, we should specify some random starting
## points in the "values" column.
startTab <- parTab
startTab$values <- c(3.5,1)
## You could have done something like this:
## startTab$values <- runif(nrow(startTab), startTab$lower_bound, startTab$upper_bound)
output <- run_MCMC(parTab=startTab, data=data, mcmcPars=mcmcPars, filename="test",
CREATE_POSTERIOR_FUNC=my_creation_func, mvrPars=NULL,
PRIOR_FUNC = my_prior, OPT_TUNING=0.2)
mean <- 5
sd <- 2
data <- rnorm(10000, mean=mean, sd=sd)
parTab <- data.frame(values=c(5,2),
names=c("mu","sd"),
fixed=0,
lower_bound=c(-Inf,-Inf),
upper_bound=c(Inf,Inf),
steps=c(0.1,0.1))
my_creation_function <- function(parTab, data, PRIOR_FUNC, ...){
##############################
## This is where you would manipulate all
## of your model arguments. For example,
## unpackaging the stuff from `...`,
## or transforming model parameters
##############################
## Somewhat redundant example
parameter_names <- parTab$names
##############################
## This is where you would put your own model code
##############################
f <- function(pars){
names(pars) <- names
mu <- pars["mu"]
sd <- pars["sd"]
## Note the use of closures to capture the `data` argument
lik <- sum(dnorm(data, mu, sd, TRUE))
if(!is.null(PRIOR_FUNC)) lik <- lik + PRIOR_FUNC(pars)
lik
}
return(f)
}
my_prior <- function(pars){
a <- dnorm(pars["mu"],5,10,1)
b <- dnorm(pars["sd"],2,10,1)
return(a + b)
}
posterior <- my_creation_function(parTab, data, my_prior)
print(posterior(parTab$values))
parTab$values
data
print(posterior(parTab$values))
parTab
source('~/.active-rstudio-document', echo=TRUE)
print(posterior(parTab$values))
mean <- 5
sd <- 2
data <- rnorm(10000, mean=mean, sd=sd)
parTab <- data.frame(values=c(5,2),
names=c("mu","sd"),
fixed=0,
lower_bound=c(-Inf,Inf),
upper_bound=c(-Inf,Inf),
steps=c(0.1,0.1))
my_creation_function <- function(parTab, data, PRIOR_FUNC, ...){
##############################
## This is where you would manipulate all
## of your model arguments. For example,
## unpackaging the stuff from `...`,
## or transforming model parameters
##############################
## Somewhat redundant example
names <- parTab$names
##############################
## This is where you would put your own model code
##############################
f <- function(pars){
names(pars) <- names
mu <- pars["mu"]
sd <- pars["sd"]
## Note the use of closures to capture the `data` argument
lik <- sum(dnorm(data, mu, sd, TRUE))
if(!is.null(PRIOR_FUNC)) lik <- lik + PRIOR_FUNC(pars)
lik
}
return(f)
}
## Note that we've given it a prior function too. lazymcmc will
## combine this function pointer with the likelihood function.
my_prior <- function(pars){
a <- dnorm(pars["mu"],5,10,1)
b <- dnorm(pars["sd"],2,10,1)
return(a + b)
}
## To test that it's working
posterior <- my_creation_function(parTab, data, my_prior)
print(posterior(parTab$values))
mcmcPars <- c("iterations"=10000,"popt"=0.44,"opt_freq"=1000,
"thin"=1,"adaptive_period"=5000,"save_block"=100)
## The MCMC code uses the parameter table. Here, we should specify some random starting
## points in the "values" column.
startTab <- parTab
startTab$values <- c(3.5,1)
## You could have done something like this:
## startTab$values <- runif(nrow(startTab), startTab$lower_bound, startTab$upper_bound)
output <- run_MCMC(parTab=startTab, data=data, mcmcPars=mcmcPars, filename="test",
CREATE_POSTERIOR_FUNC=my_creation_func, mvrPars=NULL,
PRIOR_FUNC = my_prior, OPT_TUNING=0.2)
source('~/.active-rstudio-document', echo=TRUE)
output
starttab
source('~/.active-rstudio-document', echo=TRUE)
output
library(lazymcmc)
data <- 13
parTab <- data.frame(values=c(0.5,16),
names=c("p","n"),
fixed=c(0,1),
lower_bound=c(0,1),
upper_bound=c(15,17),
steps=c(0.1,0.1))
f_create <- function(parTab, data, PRIOR_FUNC, ...){
f <- function(pars){
names(pars) <- parTab$names
lik <- dbinom(x=data, size=pars["n"],p=pars["p"],log=TRUE)
return(lik)
}
}
post <- f_create(parTab, data, NULL)
post(c(13/16,16))
mcmcPars <- c("iterations"=10000,"popt"=0.44,"opt_freq"=1000,
"thin"=1,"adaptive_period"=5000,"save_block"=100)
## The MCMC code uses the parameter table. Here, we should specify some random starting
## points in the "values" column.
startTab <- parTab
## You could have done something like this:
## startTab$values <- runif(nrow(startTab), startTab$lower_bound, startTab$upper_bound)
output <- run_MCMC(parTab=startTab, data=data, mcmcPars=mcmcPars, filename="test",
CREATE_POSTERIOR_FUNC=f_create, mvrPars=NULL,
PRIOR_FUNC = NULL, OPT_TUNING=0.2)
warnings()
library(lazymcmc)
data <- 13
parTab <- data.frame(values=c(0.5,16),
names=c("p","n"),
fixed=c(0,1),
lower_bound=c(0,1),
upper_bound=c(15,17),
steps=c(0.1,0.1))
f_create <- function(parTab, data, PRIOR_FUNC, ...){
f <- function(pars){
names(pars) <- parTab$names
lik <- dbinom(x=data, size=pars["n"],p=pars["p"],log=TRUE)
return(lik)
}
}
post <- f_create(parTab, data, NULL)
post(c(13/16,16))
mcmcPars <- c("iterations"=10000,"popt"=0.44,"opt_freq"=1000,
"thin"=1,"adaptive_period"=5000,"save_block"=100)
## The MCMC code uses the parameter table. Here, we should specify some random starting
## points in the "values" column.
startTab <- parTab
## You could have done something like this:
## startTab$values <- runif(nrow(startTab), startTab$lower_bound, startTab$upper_bound)
output <- run_MCMC(parTab=startTab, data=data, mcmcPars=mcmcPars, filename="test",
CREATE_POSTERIOR_FUNC=f_create, mvrPars=NULL,
PRIOR_FUNC = NULL, OPT_TUNING=0.2)
chain <- read.csv(output$file)
plot(coda::as.mcmc(chain[chain$sampno > mcmcPars["adaptive_period"],]))
chain <- coda::as.mcmc(chain[chain$sampno > mcmcPars["adaptive_period"],])
mean(chain[,"p"])
source('~/.active-rstudio-document', echo=TRUE)
mean(chain[,"p"])
which.max(chain$lnlike)
which.max(chain[,"lnlike"])
chain[which.max(chain[,"lnlike"]),]
median(chain[,"p"])
summary(chain)
dbinom(13,16,seq(0,1,by=0.1))
dbinom(13,16,seq(0,1,by=0.01))
plot(dbinom(13,16,seq(0,1,by=0.01)))
sapply(seq(0,1,by=0.01),function(x) rbinom(1000,16,x))
wow <- sapply(seq(0,1,by=0.01),function(x) rbinom(1000,16,x))
colMeans(wow)
rowMeans(wow)
colMeans(wow)
which(colMeans(wow) == 13.036)
dbinom(13,16,seq(0,1,by=0.01))
plot(dbinom(13,16,seq(0,1,by=0.01)))
plot(dbinom(13,16,seq(0,1,by=0.01)))
plot(dbinom(13,16,seq(0,1,by=0.01))*(16*seq(0,1,by=0.01)))
sum(dbinom(13,16,seq(0,1,by=0.01))*(16*seq(0,1,by=0.01)))
ps <- NULL
for(i in 1:1000){
p <- (i-1)/1000
ps[i] <- dbinom(13,16,p)*16*p
}
sum(ps)
ps <- NULL
for(i in 1:1000){
p <- (i-1)/1000
ps[i] <- dbinom(13,16,p)*p
}
sum(ps)
p
plot(ps)
ps <- NULL
for(i in 1:1000){
p <- (i-1)/1000
ps[i] <- dbinom(13,16,p)
}
sum(ps)
plot(ps)
traceback()
library(coda)
runs <- data.frame("mean"=7,"var"=c(10,25,50,100))
runs <- mefa:::rep.data.frame(runs,2)
runs <- cbind(runs, "buckets"=c(rep(1,4),rep(12,4)))
runs$runName <- paste("var_test",runs$mean,runs$var,runs$buckets,sep="_")
runs$runName <- as.character(runs$runName)
runs$mean <- as.numeric(runs$mean)
runs$var <- as.numeric(runs$var)
runs$buckets <- as.numeric(runs$buckets)
runs <- runs[,c("runName","mean","var","buckets")]
wds <- unique(as.character(runs$runName))
saveDir <- "~/Documents/Fluscape/serosolver_own/sim_var/"
ess_univ_all <- NULL
max_gelman_univ_all <- NULL
mean_gelman_univ_all <- NULL
mpsrf_gelman_univ_all <- NULL
gelman_hist_all <- NULL
ess_hist_all <- NULL
burnin1 <- 100000
parEstimatesAll <- NULL
index <- 1
for(wd in wds){
index <- index + 1
print(wd)
actualWd <- paste0("~/net/home/serosolver/outputs/",wd)
buckets <- runs[runs$runName == wd, "buckets"]
mean <- runs[runs$runName == wd,"mean"]
var <- runs[runs$runName == wd,"var"]
if(length(Sys.glob(file.path(actualWd,"*_chain.pdf"))) != 3){
max_gelman_univ_all <- c(max_gelman_univ_all, NA)
mean_gelman_univ_all <- c(mean_gelman_univ_all, NA)
mpsrf_gelman_univ_all <- c(mpsrf_gelman_univ_all, NA)
ess_univ_all <- c(ess_univ_all, NA)
} else {
chain_files <- Sys.glob(file.path(actualWd, "*_chain.csv"))
chains_univ <- NULL
for(i in 1:length(chain_files)){
tmp <- data.table::fread(chain_files[i],data.table=FALSE)
vars <- c("sampno","mu", "mu_short", "wane", "tau", "sigma1", "sigma2", "error",
"lnlike")
tmp <- as.mcmc(tmp[tmp$sampno > burnin1,vars])
chains_univ[[i]] <- tmp
}
vars1 <- c("mu", "mu_short", "wane", "tau", "sigma1", "sigma2", "error",
"lnlike")
maxSampno <- min(as.numeric(lapply(chains_univ,function(x) max(x[,"sampno"]))))
for(i in 1:length(chains_univ)) chains_univ[[i]] <- as.mcmc(chains_univ[[i]][chains_univ[[i]][,"sampno"] < maxSampno,vars1])
chains_univ <- as.mcmc.list(chains_univ)
parEst <- summary(chains_univ)
lower_quant <- parEst[[2]][,1]
upper_quant <- parEst[[2]][,5]
meanPar <- parEst[[1]][,1]
parEstimates <- data.frame("var"=names(meanPar),"mean"=meanPar,"lower"=lower_quant,"upper"=upper_quant,
"runName"=wd, "mean1"=mean,"var"=var,"buckets"=buckets)
parEstimatesAll <- rbind(parEstimatesAll, parEstimates)
chainName1 <- paste0(saveDir, wd,"_univ.pdf")
pdf(chainName1)
plot(chains_univ)
dev.off()
######## Infection histories
hist_files <- Sys.glob(file.path(actualWd, "*_infectionHistories.csv"))
hist_chains <- NULL
for(i in 1:length(hist_files)){
infChain <- data.table::fread(hist_files[i],data.table=FALSE)
infChain <- infChain[infChain$sampno >= (mcmcPars["adaptive_period"]+mcmcPars["burnin"]),]
infChain <- infChain[infChain$sampno %in% seq(min(infChain$sampno),max(infChain$sampno),by=10),]
n_infs <- ddply(infChain, ~individual, function(x) summary(rowSums(x[,1:(ncol(x)-2)])))
n_inf_chain <- ddply(infChain, c("individual","sampno"), function(x) rowSums(x[,1:(ncol(x)-2)]))
n_hist_chain <- reshape2::dcast(n_inf_chain, sampno~individual, drop=TRUE)
hist_chains[[i]] <- n_hist_chain
}
maxSampno <- min(as.numeric(lapply(hist_chains,function(x) max(x[,"sampno"]))))
for(i in 1:length(hist_chains)) hist_chains[[i]] <- as.mcmc(hist_chains[[i]][hist_chains[[i]][,"sampno"] < maxSampno,2:ncol(hist_chains[[i]])])
hist_chains <- as.mcmc.list(hist_chains)
chainName2 <- paste0(saveDir, wd,"_hist.pdf")
pdf(chainName2)
plot(hist_chains)
dev.off()
ess_hist <- min(effectiveSize(hist_chains))
gelman_hist <- gelman.diag(hist_chains)
gelman_hist_all <- c(gelman_hist_all, max(gelman_hist$psrf[,2]))
ess_hist_all <- c(ess_hist_all, ess_hist)
ess_univ <- min(effectiveSize(chains_univ))
gelman_univ <- gelman.diag(chains_univ)
ess_univ_all <- c(ess_univ_all, ess_univ)
max_gelman_univ <- max(gelman_univ$psrf[,2])
mean_gelman_univ <- mean(gelman_univ$psrf[,2])
mpsrf_gelman_univ <- gelman_univ$mpsrf
max_gelman_univ_all <- c(max_gelman_univ_all, max_gelman_univ)
mean_gelman_univ_all <- c(mean_gelman_univ_all, mean_gelman_univ)
mpsrf_gelman_univ_all <- c(mpsrf_gelman_univ_all, mpsrf_gelman_univ)
}
}
source('~/Documents/Fluscape/serosolver/scripts/convergence_checks_var.R', echo=TRUE)
source('~/Documents/Fluscape/serosolver/scripts/convergence_checks_var.R', echo=TRUE)
source('~/Documents/Fluscape/serosolver/scripts/convergence_checks_var.R', echo=TRUE)
source('~/Documents/Fluscape/serosolver/scripts/convergence_checks_var.R', echo=TRUE)
source('~/Documents/Fluscape/serosolver/scripts/convergence_checks_var.R', echo=TRUE)
head(parEstimatesAll)
parEstimatesAll$mean1 <- as.factor(parEstimatesAll$mean1)
parEstimatesAll$var.1 <- as.factor(parEstimatesAll$var.1)
parEstimatesAll$buckets <- as.factor(parEstimatesAll$buckets)
parTab <- read.csv("~/net/home/serosolver/inputs/parTab.csv",stringsAsFactors=FALSE)
parTab <- parTab[parTab$fixed == 0,]
colnames(parTab)[1] <- "var"
p <- ggplot(parEstimatesAll) + geom_pointrange(aes(x=runName, y = mean,ymin=lower,ymax=upper, col=version,shape=histProposal)) +
geom_hline(data=parTab, aes(yintercept=values),linetype="dashed")+
facet_wrap(~var,scales="free_y") +
theme(axis.text.x=element_text(angle=90,hjust=0.5,size=6))
library(ggplot2)
p <- ggplot(parEstimatesAll) + geom_pointrange(aes(x=runName, y = mean,ymin=lower,ymax=upper, col=version,shape=histProposal)) +
geom_hline(data=parTab, aes(yintercept=values),linetype="dashed")+
facet_wrap(~var,scales="free_y") +
theme(axis.text.x=element_text(angle=90,hjust=0.5,size=6))
p
p <- ggplot(parEstimatesAll) + geom_pointrange(aes(x=runName, y = mean,ymin=lower,ymax=upper, col=buckets,shape=var.1)) +
geom_hline(data=parTab, aes(yintercept=values),linetype="dashed")+
facet_wrap(~var,scales="free_y") +
theme(axis.text.x=element_text(angle=90,hjust=0.5,size=6))
p
pdf("~/Documents/Fluscape/serosolver_own/sim_var/simrecover.pdf")
plot(p)
dev.off()
svg("~/Documents/Fluscape/serosolver_own/sim_var/simrecover.svg", width=10,height=9)
plot(p)
dev.off()
res <- data.frame(wds, runs$runName, runs$version, runs$histProposal, runs$histOpt,ess_univ_all,
max_gelman_univ_all, mean_gelman_univ_all, mpsrf_gelman_univ_all,
gelman_hist_all, ess_hist_all)
res <- data.frame(wds, runs$runName, runs$mean1, runs$var.1, runs$buckets,ess_univ_all,
max_gelman_univ_all, mean_gelman_univ_all, mpsrf_gelman_univ_all,
gelman_hist_all, ess_hist_all)
wds
runs$runName
runs$mean1
res <- data.frame(wds, runs$runName, runs$mean, runs$var.1, runs$buckets,ess_univ_all,
max_gelman_univ_all, mean_gelman_univ_all, mpsrf_gelman_univ_all,
gelman_hist_all, ess_hist_all)
res <- data.frame(wds, runs$runName, runs$mean, runs$var, runs$buckets,ess_univ_all,
max_gelman_univ_all, mean_gelman_univ_all, mpsrf_gelman_univ_all,
gelman_hist_all, ess_hist_all)
write.table(res,"~/Documents/Fluscape/serosolver_own/sim_priors/simrecover_res.csv",row.names=FALSE,sep=",")
write.table(parEstimatesAll,"~/Documents/Fluscape/serosolver_own/sim_priors/simrecover_parEst.csv",row.names=FALSE,sep=",")
source('~/Documents/Fluscape/serosolver/scripts/sim/sim_run.R', echo=TRUE)
devtools::document()

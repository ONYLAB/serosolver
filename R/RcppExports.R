# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Model function
#'
#' The main model solving function for a single individual.
#' NOTES:
#' - Do we want infection history to be a vector of infection times?
#' - Treat the contents of infectionHistory as a parameter (ie. exposure type)
#' @param theta NumericVector, the named vector of model parameters
#' @param infectionHistory IntegerVector, the vector of 1s and 0s showing presence/absence of infection for each possible time. 
#' @param infectionTimes NumericVector, the actual times of circulation that the infection history vector corresponds to
#' @param infectionMapIndices IntegerVector, which entry in the melted antigenic map that these infection times correspond to
#' @param samplingTime double, the real time that the sample was taken
#' @param measurementMapIndices IntegerVector, the indices of all measured strains in the melted antigenic map
#' @param antigenicMapLong NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenicMapShort NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param numberStrains int, the maximum number of infections that an individual could experience
#' @return NumericVector of predicted titres for each entry in measurementMapIndices
#' @useDynLib serosolver
#' @export
infection_model_indiv <- function(theta, infectionHistory, infectionTimes, infectionMapIndices, samplingTime, measurementMapIndices, antigenicMapLong, antigenicMapShort, numberStrains) {
    .Call('_serosolver_infection_model_indiv', PACKAGE = 'serosolver', theta, infectionHistory, infectionTimes, infectionMapIndices, samplingTime, measurementMapIndices, antigenicMapLong, antigenicMapShort, numberStrains)
}

#' @export
titre_data_individual <- function(theta, infectionHistory, circulationTimes, circulationMapIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains) {
    .Call('_serosolver_titre_data_individual', PACKAGE = 'serosolver', theta, infectionHistory, circulationTimes, circulationMapIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains)
}

titre_data_group <- function(theta, infectionHistories, circulationTimes, circulationMapIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort) {
    .Call('_serosolver_titre_data_group', PACKAGE = 'serosolver', theta, infectionHistories, circulationTimes, circulationMapIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort)
}

#' Calculate likelihood
#'
#' Calculates the likelihood of a given set of observed titres given predicted titres. Based on truncated discritised normal.
#' @param expected NumericVector, as returned by \code{\link{infection_model_indiv}}
#' @param data NumericVector, the vector of observed titres
#' @param theta NumericVector, the vector of named model parameters, requiring MAX_TITRE and error
#' @return a single log likelihood
#' @export
likelihood_titre <- function(expected, data, theta) {
    .Call('_serosolver_likelihood_titre', PACKAGE = 'serosolver', expected, data, theta)
}

#' @export
likelihood_data_individual <- function(theta, infectionHistory, circulationTimes, circulationMapIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains, data) {
    .Call('_serosolver_likelihood_data_individual', PACKAGE = 'serosolver', theta, infectionHistory, circulationTimes, circulationMapIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains, data)
}

#' Calculate likelihood
#'
#' Calculates the likelihood of a given set of observed titres given predicted titres. Based on truncated discritised normal.
#' @param expected NumericVector, as returned by \code{\link{infection_model_indiv}}
#' @param data NumericVector, the vector of observed titres
#' @param theta NumericVector, the vector of named model parameters, requiring MAX_TITRE and error
#' @return a single log likelihood
#' @export
likelihood_titre_bias <- function(expected, data, theta, to_add) {
    .Call('_serosolver_likelihood_titre_bias', PACKAGE = 'serosolver', expected, data, theta, to_add)
}

#' @export
likelihood_data_individual_bias <- function(theta, infectionHistory, circulationTimes, circulationMapIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains, data, to_add) {
    .Call('_serosolver_likelihood_data_individual_bias', PACKAGE = 'serosolver', theta, infectionHistory, circulationTimes, circulationMapIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains, data, to_add)
}

#' Individual likelihood
#'
#' Uses \code{\link{infection_model_indiv}} for a single individual and then calls \code{\link{likelihood_titre}}. Works with NA
#' @param theta NumericVector, the named vector of model parameters
#' @param infectionHistory NumericVector, the vector of 1s and 0s showing presence/absence of infection for each possible time. 
#' @param samplingTimes NumericVector, the vector of real times that samples were taken
#' @param strainIsolationTimes NumericVector, the vector of times at which each virus strain circulated
#' @param antigenicMapLong NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenicMapShort NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param titres NumericVector, the vector of observed titres.
#' @return a single log likelihood
#' @useDynLib serosolver
#' @export
individual_likelihood <- function(theta, infectionHistory, samplingTimes, indivIndices, strainIsolationTimes, indivVirusIndices, antigenicMapLong, antigenicMapShort, titres, numberStrains) {
    .Call('_serosolver_individual_likelihood', PACKAGE = 'serosolver', theta, infectionHistory, samplingTimes, indivIndices, strainIsolationTimes, indivVirusIndices, antigenicMapLong, antigenicMapShort, titres, numberStrains)
}

#' Group likelihood
#'
#' Uses \code{\link{individual_likelihood}} for each individual and returns a vector of log likelihoods for each individual
#' @param theta NumericVector, the named vector of model parameters
#' @param infectionHistories NumericMatrix, the matrix of 1s and 0s showing presence/absence of infection for each possible time for each individual 
#' @param indicesSampling IntegerVector, the range of indices of the titre vector that correspond to each individual (eg. first 5 titres are for indiv 1, indicesA = c(0,5,...)
#' @param indicesData IntegerVector, the range of indices of the sample vector that correspond to each individual (eg. first 2 sampling times are for indiv 1, indicesB = c(0,2,...)
#' @param samplingTimes NumericVector, the vector of real times that samples were taken
#' @param strainIsolationTimes NumericVector, the vector of times at which each virus strain circulated
#' @param antigenicMapLong NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenicMapShort NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param titres NumericVector, the vector of observed titres for all individuals.
#' @param n_strains int, the maximum number of strains that could be tested against
#' @return a NumericVector of log likelihoods for each individual
#' @useDynLib serosolver
#' @export
group_likelihood_vector <- function(theta, infectionHistories, indicesSamples, indicesData, indicesDataOverall, samplingTimes, strainIsolationTimes, virusIndices, antigenicMapLong, antigenicMapShort, titres) {
    .Call('_serosolver_group_likelihood_vector', PACKAGE = 'serosolver', theta, infectionHistories, indicesSamples, indicesData, indicesDataOverall, samplingTimes, strainIsolationTimes, virusIndices, antigenicMapLong, antigenicMapShort, titres)
}

#' Group likelihood
#'
#' Uses \code{\link{individual_likelihood}} for each individual and returns a summed log likelihood for all individuals
#' @param theta NumericVector, the named vector of model parameters
#' @param infectionHistories NumericMatrix, the matrix of 1s and 0s showing presence/absence of infection for each possible time for each individual 
#' @param indicesA IntegerVector, the range of indices of the titre vector that correspond to each individual (eg. first 5 titres are for indiv 1, indicesA = c(0,5,...)
#' @param indicesB IntegerVector, the range of indices of the sample vector that correspond to each individual (eg. first 2 sampling times are for indiv 1, indicesB = c(0,2,...)
#' @param samplingTimes NumericVector, the vector of real times that samples were taken
#' @param strainIsolationTimes NumericVector, the vector of times at which each virus strain circulated
#' @param antigenicMapLong NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenicMapShort NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param titres NumericVector, the vector of observed titres for all individuals.
#' @return a single log likelihood
#' @useDynLib serosolver
#' @export
group_likelihood_total <- function(theta, infectionHistories, indicesSamples, indicesData, indicesDataOverall, samplingTimes, strainIsolationTimes, virusIndices, antigenicMapLong, antigenicMapShort, titres) {
    .Call('_serosolver_group_likelihood_total', PACKAGE = 'serosolver', theta, infectionHistories, indicesSamples, indicesData, indicesDataOverall, samplingTimes, strainIsolationTimes, virusIndices, antigenicMapLong, antigenicMapShort, titres)
}

#' Sums a vector based on bucket sizes
#'
#' Given a vector (a) and another vector of bucket sizes, returns the summed vector (a)
#' @param a the vector to be bucketed
#' @param buckets the vector of bucket sizes to sum a over
#' @return the vector of summed a
#' @export
sum_buckets <- function(a, buckets) {
    .Call('_serosolver_sum_buckets', PACKAGE = 'serosolver', a, buckets)
}

#' Convert melted antigenic map to cross reactivity
#'
#' Multiplies all elements of the provided vector, x such that y = 1 - sigma*x. Also makes sure that no calculated value is less than 0
#' @param x the melted antigenic map
#' @param sigma the cross reactivity waning parameter
#' @return a vector of cross reactivity
create_cross_reactivity_vector <- function(x, sigma) {
    .Call('_serosolver_create_cross_reactivity_vector', PACKAGE = 'serosolver', x, sigma)
}

#' Original model reimplementation
#' @export
c_model_original <- function(n, nsamp, x, theta, dd, dd2, t_sample) {
    .Call('_serosolver_c_model_original', PACKAGE = 'serosolver', n, nsamp, x, theta, dd, dd2, t_sample)
}

#' Model function
#'
#' The main model solving function for a single individual.
#' NOTES:
#' - Do we want infection history to be a vector of infection times?
#' - Treat the contents of infectionHistory as a parameter (ie. exposure type)
#' @param theta NumericVector, the named vector of model parameters
#' @param mus NumericVector, the vector of boosting parameters corresponding to each circulation time
#' @param boostingVecIndices, which index in the mus vector does each potential infection correspond to?
#' @param infectionHistory IntegerVector, the vector of 1s and 0s showing presence/absence of infection for each possible time. 
#' @param infectionTimes NumericVector, the actual times of circulation that the infection history vector corresponds to
#' @param infectionMapIndices IntegerVector, which entry in the melted antigenic map that these infection times correspond to
#' @param samplingTime double, the real time that the sample was taken
#' @param measurementMapIndices IntegerVector, the indices of all measured strains in the melted antigenic map
#' @param antigenicMapLong NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenicMapShort NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param numberStrains int, the maximum number of infections that an individual could experience
#' @return NumericVector of predicted titres for each entry in measurementMapIndices
#' @useDynLib serosolver
#' @export
infection_model_indiv_mus <- function(theta, mus, infectionHistory, infectionTimes, boostingVecIndices, infectionMapIndices, samplingTime, measurementMapIndices, antigenicMapLong, antigenicMapShort, numberStrains) {
    .Call('_serosolver_infection_model_indiv_mus', PACKAGE = 'serosolver', theta, mus, infectionHistory, infectionTimes, boostingVecIndices, infectionMapIndices, samplingTime, measurementMapIndices, antigenicMapLong, antigenicMapShort, numberStrains)
}

#' @export
titre_data_individual_mus <- function(theta, mus, infectionHistory, circulationTimes, circulationMapIndices, musIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains) {
    .Call('_serosolver_titre_data_individual_mus', PACKAGE = 'serosolver', theta, mus, infectionHistory, circulationTimes, circulationMapIndices, musIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains)
}

titre_data_group_mus <- function(theta, mus, infectionHistories, circulationTimes, circulationMapIndices, musIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort) {
    .Call('_serosolver_titre_data_group_mus', PACKAGE = 'serosolver', theta, mus, infectionHistories, circulationTimes, circulationMapIndices, musIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort)
}

#' @export
likelihood_data_individual_mus <- function(theta, mus, infectionHistory, circulationTimes, circulationMapIndices, musIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains, data) {
    .Call('_serosolver_likelihood_data_individual_mus', PACKAGE = 'serosolver', theta, mus, infectionHistory, circulationTimes, circulationMapIndices, musIndices, samplingTimes, dataIndices, measuredMapIndices, antigenicMapLong, antigenicMapShort, numberStrains, data)
}

#' Marginal prior probability (p(Z)) of a particular infection history matrix
#' 
#' @param infHist IntegerMatrix, the infection history matrix
#' @param n_alive IntegerVector, vector giving the number of individuals alive in each year
#' @param alpha double, alpha parameter for beta distribution prior
#' @param beta double, beta parameter for beta distribution prior
inf_mat_prior_cpp <- function(infHist, n_alive, alpha, beta) {
    .Call('_serosolver_inf_mat_prior_cpp', PACKAGE = 'serosolver', infHist, n_alive, alpha, beta)
}

#' Gibbs sampling of infection histories
#'
#' Proposes a new matrix of infection histories by sampling from the prior on an individual's infection presence/absence in a particular time period, conditional on all other individuals in that time period. This allows us to integrate out the infection probability term for each time period. Should look at \code{\link{create_post_func}} for more details about the input parameters.
#' @param pars NumericVector, the model parameters used to solve the model, extract likelihood function parameters and alpha/beta
#' @param infHist IntegerMatrix the matrix of 1s and 0s corresponding to individual infection histories
#' @param indivSampPropn double, what proportion of individuals to resample in this proposal step
#' @param n_years_samp int, for each individual, how many time periods to resample infections for?
#' @param ageMask IntegerVector, length of the number of individuals, with indices specifying first time period that an individual can be infected (indexed from 1, such that a value of 1 allows an individual to be infected in any time period)
#' @param n_alive IntegerVector, length of the number of time periods that an individual could be infected, giving the number of individual alive in each time period
#' @param swapPropn double, what proportion of proposals should be swap steps (ie. swap contents of two cells in infHist rather than adding/removing infections)
#' @param swapDistance int, in a swap step, how many time steps either side of the chosen time period to swap with
#' @param alpha double, alpha parameter for beta prior on infection probability
#' @param beta double, beta parameter for beta prior on infection probability
#' @param circulationTimes NumericVector, the times that each strain circulated
#' @param circulationMapIndices IntegerVector, indexing vector from 1:number of strains
#' @param samplingTimes NumericVector, the vector of real times that samples were taken
#' @param indicesTitreDataSamples IntegerVector, How many rows in titre data correspond to each individual, sample and repeat?
#' @param indicesTitreDataOverall IntegerVector, How many rows in the titre data correspond to each individual?
#' @param indicesSamples IntegerVector, Split the sample times and runs for each individual
#' @param measuredMapIndices IntegerVector, For each titre measurement, corresponding entry in antigenic map
#' @param antigenicMapLong NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenicMapShort NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param data NumericVector, the titre data for all individuals
#' @param temp double, temperature for parallel tempering MCMC
#' @return a matrix of 1s and 0s corresponding to the infection histories for all individuals
infection_history_proposal_gibbs <- function(pars, infHist, indivSampPropn, n_years_samp, ageMask, n_alive, swapPropn, swapDistance, alpha, beta, circulationTimes, circulationMapIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort, data, temp) {
    .Call('_serosolver_infection_history_proposal_gibbs', PACKAGE = 'serosolver', pars, infHist, indivSampPropn, n_years_samp, ageMask, n_alive, swapPropn, swapDistance, alpha, beta, circulationTimes, circulationMapIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort, data, temp)
}

#' Gibbs sampling of infection histories
#'
#' Proposes a new matrix of infection histories by sampling from the prior on an individual's infection presence/absence in a particular time period, conditional on all other individuals in that time period. This allows us to integrate out the infection probability term for each time period. Should look at \code{\link{create_post_func}} for more details about the input parameters.
#' @param pars NumericVector, the model parameters used to solve the model, extract likelihood function parameters and alpha/beta
#' @param infHist IntegerMatrix the matrix of 1s and 0s corresponding to individual infection histories
#' @param indivSampPropn double, what proportion of individuals to resample in this proposal step
#' @param n_years_samp int, for each individual, how many time periods to resample infections for?
#' @param ageMask IntegerVector, length of the number of individuals, with indices specifying first time period that an individual can be infected (indexed from 1, such that a value of 1 allows an individual to be infected in any time period)
#' @param n_alive IntegerVector, length of the number of time periods that an individual could be infected, giving the number of individual alive in each time period
#' @param swapPropn double, what proportion of proposals should be swap steps (ie. swap contents of two cells in infHist rather than adding/removing infections)
#' @param swapDistance int, in a swap step, how many time steps either side of the chosen time period to swap with
#' @param alpha double, alpha parameter for beta prior on infection probability
#' @param beta double, beta parameter for beta prior on infection probability
#' @param circulationTimes NumericVector, the times that each strain circulated
#' @param circulationMapIndices IntegerVector, indexing vector from 1:number of strains
#' @param samplingTimes NumericVector, the vector of real times that samples were taken
#' @param indicesTitreDataSamples IntegerVector, How many rows in titre data correspond to each individual, sample and repeat?
#' @param indicesTitreDataOverall IntegerVector, How many rows in the titre data correspond to each individual?
#' @param indicesSamples IntegerVector, Split the sample times and runs for each individual
#' @param measuredMapIndices IntegerVector, For each titre measurement, corresponding entry in antigenic map
#' @param antigenicMapLong NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenicMapShort NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param data NumericVector, the titre data for all individuals
#' @param temp double, tepmerature for parallel tempering
#' @return a matrix of 1s and 0s corresponding to the infection histories for all individuals
infection_history_proposal_gibbs_bias <- function(pars, infHist, indivSampPropn, n_years_samp, ageMask, n_alive, swapPropn, swapDistance, alpha, beta, circulationTimes, circulationMapIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort, data, to_add, temp) {
    .Call('_serosolver_infection_history_proposal_gibbs_bias', PACKAGE = 'serosolver', pars, infHist, indivSampPropn, n_years_samp, ageMask, n_alive, swapPropn, swapDistance, alpha, beta, circulationTimes, circulationMapIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort, data, to_add, temp)
}

#' Gibbs sampling of infection histories with random effects boosting
#'
#' Proposes a new matrix of infection histories by sampling from the prior on an individual's infection presence/absence in a particular time period, conditional on all other individuals in that time period. This allows us to integrate out the infection probability term for each time period. Should look at \code{\link{create_post_func}} for more details about the input parameters.
#' @param pars NumericVector, the model parameters used to solve the model, extract likelihood function parameters and alpha/beta
#' @param mus NumericVector, boosting parameters for random effects boosting
#' @param mu_indices IntegerVector, boosting parameter indices for random effects boosting
#' @param infHist IntegerMatrix the matrix of 1s and 0s corresponding to individual infection histories
#' @param indivSampPropn double, what proportion of individuals to resample in this proposal step
#' @param n_years_samp int, for each individual, how many time periods to resample infections for?
#' @param ageMask IntegerVector, length of the number of individuals, with indices specifying first time period that an individual can be infected (indexed from 1, such that a value of 1 allows an individual to be infected in any time period)
#' @param n_alive IntegerVector, length of the number of time periods that an individual could be infected, giving the number of individual alive in each time period
#' @param swapPropn double, what proportion of proposals should be swap steps (ie. swap contents of two cells in infHist rather than adding/removing infections)
#' @param swapDistance int, in a swap step, how many time steps either side of the chosen time period to swap with
#' @param alpha double, alpha parameter for beta prior on infection probability
#' @param beta double, beta parameter for beta prior on infection probability
#' @param circulationTimes NumericVector, the times that each strain circulated
#' @param circulationMapIndices IntegerVector, indexing vector from 1:number of strains
#' @param samplingTimes NumericVector, the vector of real times that samples were taken
#' @param indicesTitreDataSamples IntegerVector, How many rows in titre data correspond to each individual, sample and repeat?
#' @param indicesTitreDataOverall IntegerVector, How many rows in the titre data correspond to each individual?
#' @param indicesSamples IntegerVector, Split the sample times and runs for each individual
#' @param measuredMapIndices IntegerVector, For each titre measurement, corresponding entry in antigenic map
#' @param antigenicMapLong NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenicMapShort NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param data NumericVector, the titre data for all individuals
#' @param temp double, tepmerature for parallel tempering
#' @return a matrix of 1s and 0s corresponding to the infection histories for all individuals
infection_history_proposal_gibbs_mus <- function(pars, mus, mu_indices, infHist, indivSampPropn, n_years_samp, ageMask, n_alive, swapPropn, swapDistance, alpha, beta, circulationTimes, circulationMapIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort, data, temp) {
    .Call('_serosolver_infection_history_proposal_gibbs_mus', PACKAGE = 'serosolver', pars, mus, mu_indices, infHist, indivSampPropn, n_years_samp, ageMask, n_alive, swapPropn, swapDistance, alpha, beta, circulationTimes, circulationMapIndices, samplingTimes, indicesTitreDataSample, indicesTitreDataOverall, indicesSamples, measuredMapIndices, antigenicMapLong, antigenicMapShort, data, temp)
}

#' Fast infection history proposal function
#' 
#' Proposes a new matrix of infection histories using a beta binomial proposal distribution. This particular implementation allows for nInfs epoch times to be changed with each function call. Furthermore, the size of the swap step is specified for each individual by moveSizes.
#' @param infHist and RcppArmadillo matrix of infection histories, where rows represent individuals and columns represent potential infection times. The contents should be a set of 1s (presence of infection) and 0s (absence of infection)
#' @param sampledIndivs IntegerVector, indices of which individuals to resample. Note that this is indexed from 1 (ie. as if passing straight from R)
#' @param ageMask IntegerVector, for each individual gives the first column in the infection history matrix that an individual could have been exposed to indexed from 1. ie. if alive for the whole period, entry would be 1. If alive for the 11th epoch, entry would be 11.
#' @param moveSizes IntegerVector, how far can a swap step sample from specified for each individual
#' @param nInfs IntegetVector, how many infections to add/remove/swap with each proposal step for each individual
#' @param alpha double, alpha parameter of the beta binomial
#' @param beta double, beta parameter of the beta binomial
#' @param randNs NumericVector, a vector of random numbers for each sampled individual. The idea is to pre-specify whether an individual experiences an add/remove step or a swap step to avoid random number sampling in C++
#' @return a matrix of 1s and 0s corresponding to the infection histories for all individuals
inf_hist_prop_cpp <- function(infHist, sampledIndivs, ageMask, moveSizes, nInfs, alpha, beta, randNs) {
    .Call('_serosolver_inf_hist_prop_cpp', PACKAGE = 'serosolver', infHist, sampledIndivs, ageMask, moveSizes, nInfs, alpha, beta, randNs)
}

subset_test <- function(x, y) {
    .Call('_serosolver_subset_test', PACKAGE = 'serosolver', x, y)
}

subset_test1 <- function(x, y) {
    .Call('_serosolver_subset_test1', PACKAGE = 'serosolver', x, y)
}

infection_model_indiv_OLD <- function(theta, infectionHistory, samplingTime, strainIsolationTimes, virusIndices, antigenicMapLong, antigenicMapShort, numberStrains) {
    .Call('_serosolver_infection_model_indiv_OLD', PACKAGE = 'serosolver', theta, infectionHistory, samplingTime, strainIsolationTimes, virusIndices, antigenicMapLong, antigenicMapShort, numberStrains)
}


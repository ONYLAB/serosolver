# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Takes a subset of a Nullable NumericVector, but only if it isn't NULL
subset_nullable_vector <- function(x, index1, index2) {
    .Call('_serosolver_subset_nullable_vector', PACKAGE = 'serosolver', x, index1, index2)
}

#' Sum likelihoods into buckets
#' 
#' Given a large vector of likelihood values and a vector, indices, of length n_indivs, sums the likelihoods to give one value per individual, where indices indicates which individual each index of liks corresponds to.
#' @param liks NumericVector of likelihoods
#' @param indices IntegerVector of indices of same length as liks, where the max value of this should be the same as n_indivs - 1
#' @param n_indivs int, number of individuals to generate bucketed likelihoods for
#' @export
sum_likelihoods <- function(liks, indices, n_indivs) {
    .Call('_serosolver_sum_likelihoods', PACKAGE = 'serosolver', liks, indices, n_indivs)
}

#' Convert melted antigenic map to cross reactivity
#'
#' Multiplies all elements of the provided vector, x such that y = 1 - sigma*x. Also makes sure that no calculated value is less than 0
#' @param x the melted antigenic map
#' @param sigma the cross reactivity waning parameter
#' @return a vector of cross reactivity
create_cross_reactivity_vector <- function(x, sigma) {
    .Call('_serosolver_create_cross_reactivity_vector', PACKAGE = 'serosolver', x, sigma)
}

#' Sums a vector based on bucket sizes
#'
#' Given a vector (a) and another vector of bucket sizes, returns the summed vector (a)
#' @param a the vector to be bucketed
#' @param buckets the vector of bucket sizes to sum a over
#' @return the vector of summed a
#' @export
sum_buckets <- function(a, buckets) {
    .Call('_serosolver_sum_buckets', PACKAGE = 'serosolver', a, buckets)
}

#' Add measurement shifts to predictions
#'
#' Adds observation error shifts to predicted antibody titres.
#' @param predicted_titre NumericVector, the predicted titres. Note that this vector will be changed!
#' @param to_add NumericVector the vector of all measurement shifts to apply
#' @param start_index_in_data int the first index of to_add and predicted_titres to combine
#' @param end_index_in_data int the end index of to_add and predicted_titres to combine
#' @return nothing
#' @export
add_measurement_shifts <- function(predicted_titres, to_add, start_index_in_data, end_index_in_data) {
    invisible(.Call('_serosolver_add_measurement_shifts', PACKAGE = 'serosolver', predicted_titres, to_add, start_index_in_data, end_index_in_data))
}

#' Overall model function, fast implementation
#'
#' See documentation for \code{\link{titre_data_group}}, as the interface is almost identical
#' @return NumericVector of predicted titres for each entry in measurement_strain_indices
#' @export
#' @family titre_model
titre_data_fast <- function(theta, infection_history_mat, circulation_times, circulation_times_indices, sample_times, rows_per_indiv_in_samples, cum_nrows_per_individual_in_data, nrows_per_blood_sample, measurement_strain_indices, antigenic_map_long, antigenic_map_short, additional_arguments) {
    .Call('_serosolver_titre_data_fast', PACKAGE = 'serosolver', theta, infection_history_mat, circulation_times, circulation_times_indices, sample_times, rows_per_indiv_in_samples, cum_nrows_per_individual_in_data, nrows_per_blood_sample, measurement_strain_indices, antigenic_map_long, antigenic_map_short, additional_arguments)
}

#' Model function sample
#'
#' The main model solving function for a single individual for a single blood sample.
#' NOTES:
#' - Do we want infection history to be a vector of infection times?
#' - Treat the contents of infection_history as a parameter (ie. exposure type)
#' @param theta NumericVector, the named vector of model parameters
#' @param infection_history IntegerVector, the vector of 1s and 0s showing presence/absence of infection for each possible time. 
#' @param infection_times NumericVector, the actual times of circulation that the infection history vector corresponds to
#' @param infection_times_indices IntegerVector, which entry in the melted antigenic map that these infection times correspond to
#' @param samplingTime double, the real time that the sample was taken
#' @param measurement_strain_indices IntegerVector, the indices of all measured strains in the melted antigenic map
#' @param antigenic_map_long NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenic_map_short NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param number_strains int, the maximum number of infections that an individual could experience
#' @param DOB double, the date of birth of this individual. Currently not used.
#' @param additional_arguments, Nullable<List> the idea is to use this object to pass more flexible additional arguments to the bottom of the call stack (used for strain dependent boosting right now)
#' @return NumericVector of predicted titres for each entry in measurement_strain_indices
#' @useDynLib serosolver
#' @export
#' @family titre_model
infection_model_indiv <- function(theta, infection_history, infection_times, infection_times_indices, samplingTime, measurement_strain_indices, antigenic_map_long, antigenic_map_short, number_strains, DOB = 0, additional_arguments = NULL) {
    .Call('_serosolver_infection_model_indiv', PACKAGE = 'serosolver', theta, infection_history, infection_times, infection_times_indices, samplingTime, measurement_strain_indices, antigenic_map_long, antigenic_map_short, number_strains, DOB, additional_arguments)
}

#' Model function individual
#'
#' The main model solving function for a single individual for a vector of sampling times
#' @param theta NumericVector, the named vector of model parameters
#' @param infection_history IntegerVector, the vector of 1s and 0s showing presence/absence of infection for each possible time. 
#' @param circulation_times NumericVector, the actual times of circulation that the infection history vector corresponds to
#' @param circulationMapIndices IntegerVector, which entry in the melted antigenic map that these infection times correspond to
#' @param sample_times NumericVector, the times that each blood sample was taken
#' @param dataIndices IntegerVector, the indices in the overall titre data vector (of observations) that each sample corresponds to
#' @param measurement_strain_indices IntegerVector, the indices of all measured strains in the melted antigenic map
#' @param antigenic_map_long NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenic_map_short NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param number_strains int, the maximum number of infections that an individual could experience
#' @param DOB double, the date of birth of this individual. Currently not used.
#' @param additional_arguments, Nullable<List> currently not used, but the idea is to use thsi object to pass more flexible additional arguments to the bottom of the call stack
#' @return NumericVector of predicted titres for each entry in measurement_strain_indices
#' @export
#' @family titre_model
titre_data_individual <- function(theta, infection_history, circulation_times, circulation_times_indices, sample_times, data_indices, measurement_strain_indices, antigenic_map_long, antigenic_map_short, number_strains, DOB = 0, additional_arguments = NULL) {
    .Call('_serosolver_titre_data_individual', PACKAGE = 'serosolver', theta, infection_history, circulation_times, circulation_times_indices, sample_times, data_indices, measurement_strain_indices, antigenic_map_long, antigenic_map_short, number_strains, DOB, additional_arguments)
}

#' Model function overall
#'
#' The main model solving function for a single individual for a vector of sampling times
#' @param theta NumericVector, the named vector of model parameters
#' @param infection_history_mat IntegerMatrix, the matrix of 1s and 0s showing presence/absence of infection for each possible time for each individual. 
#' @param circulation_times NumericVector, the actual times of circulation that the infection history vector corresponds to
#' @param circulation_times_indices IntegerVector, which entry in the melted antigenic map that these infection times correspond to
#' @param sample_times NumericVector, the times that each blood sample was taken
#' @param rows_per_indiv_in_samples IntegerVector, Split the sample times and runs for each individual
#' @param cum_nrows_per_individual_in_data IntegerVector, How many rows in the titre data correspond to each individual?
#' @param rows_per_indiv_in_samples IntegerVector, How many rows in titre data correspond to each individual, sample and repeat?
#' @param measurement_strain_indices IntegerVector, the indices of all measured strains in the melted antigenic map
#' @param antigenic_map_long NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1 see \code{\link{create_cross_reactivity_vector}}
#' @param antigenic_map_short NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2, see \code{\link{create_cross_reactivity_vector}}
#' @param DOBs NumericVector, the date of birth of all individuals. Currently not used.
#' @param additional_arguments, Nullable<List> the idea is to use thsi object to pass more flexible additional arguments to the bottom of the call stack
#' @return NumericVector of predicted titres for each entry in measurement_strain_indices
#' @export
#' @family titre_model
titre_data_group <- function(theta, infection_history_mat, circulation_times, circulation_times_indices, sample_times, rows_per_indiv_in_samples, cum_nrows_per_individual_in_data, nrows_per_blood_sample, measurement_strain_indices, antigenic_map_long, antigenic_map_short, DOBs, additional_arguments = NULL) {
    .Call('_serosolver_titre_data_group', PACKAGE = 'serosolver', theta, infection_history_mat, circulation_times, circulation_times_indices, sample_times, rows_per_indiv_in_samples, cum_nrows_per_individual_in_data, nrows_per_blood_sample, measurement_strain_indices, antigenic_map_long, antigenic_map_short, DOBs, additional_arguments)
}

#' Likelihood for one individual
#' 
#' See \code{\link{infection_model_indiv}}, does the same thing but returns the log likelihood given some data. This is used by infection_history_proposal_gibbs
#' @export
likelihood_data_individual <- function(theta, infection_history, circulation_times, circulation_times_indices, sample_times, data_indices, measurement_strain_indices, antigenic_map_long, antigenic_map_short, number_strains, data, titre_shifts, DOB, additional_arguments) {
    .Call('_serosolver_likelihood_data_individual', PACKAGE = 'serosolver', theta, infection_history, circulation_times, circulation_times_indices, sample_times, data_indices, measurement_strain_indices, antigenic_map_long, antigenic_map_short, number_strains, data, titre_shifts, DOB, additional_arguments)
}

#' Marginal prior probability (p(Z)) of a particular infection history matrix single prior
#'  Prior is independent contribution from each year
#' @param infection_history IntegerMatrix, the infection history matrix
#' @param n_alive IntegerVector, vector giving the number of individuals alive in each time unit
#' @param alpha double, alpha parameter for beta distribution prior
#' @param beta double, beta parameter for beta distribution prior
#' @return a single prior probability
#' @export
#' @family inf_mat_prior
inf_mat_prior_cpp <- function(infection_history, n_alive, alpha, beta) {
    .Call('_serosolver_inf_mat_prior_cpp', PACKAGE = 'serosolver', infection_history, n_alive, alpha, beta)
}

#' Marginal prior probability (p(Z)) of a particular infection history matrix vector prior
#'  Prior is independent contribution from each year, but each year has its own alpha and beta
#' @param infection_history IntegerMatrix, the infection history matrix
#' @param n_alive IntegerVector, vector giving the number of individuals alive in each time unit
#' @param alphas NumericVector, alpha parameters for beta distribution prior, one for each time unit
#' @param betas NumericVector, beta parameters for beta distribution prior, one for each time unit
#' @return a single prior probability
#' @export
#' @family inf_mat_prior
inf_mat_prior_cpp_vector <- function(infection_history, n_alive, alphas, betas) {
    .Call('_serosolver_inf_mat_prior_cpp_vector', PACKAGE = 'serosolver', infection_history, n_alive, alphas, betas)
}

#' Marginal prior probability (p(Z)) of a particular infection history matrix total prior
#'  Prior here is on the total number of infections across all individuals and years
#' @param infection_history IntegerMatrix, the infection history matrix
#' @param n_alive IntegerVector, vector giving the number of individuals alive in each year
#' @param alpha double, alpha parameter for beta distribution prior
#' @param beta double, beta parameter for beta distribution prior
#' @return a single prior probability
#' @export
#' @family inf_mat_prior
inf_mat_prior_total_cpp <- function(infection_history, n_alive, alpha, beta) {
    .Call('_serosolver_inf_mat_prior_total_cpp', PACKAGE = 'serosolver', infection_history, n_alive, alpha, beta)
}

#' Fast observation error function
#'  Calculate the probability of a set of observed titres given a corresponding set of predicted titres. FAST IMPLEMENTATION
#' @param theta NumericVector, a named parameter vector giving the normal distribution standard deviation and the max observable titre
#' @param obs NumericVector, the vector of observed log titres
#' @param predicted_titres NumericVector, the vector of predicted log titres
#' @param a vector of same length as the input data giving the probability of observing each observation given the predictions
#' @return a likelihood for each observed titre
#' @export
#' @family likelihood_functions
likelihood_func_fast <- function(theta, obs, predicted_titres) {
    .Call('_serosolver_likelihood_func_fast', PACKAGE = 'serosolver', theta, obs, predicted_titres)
}

#' Calculate likelihood basic
#'
#' Calculates the likelihood of a given set of observed titres given predicted titres. Based on truncated discritised normal. DEPRECATED, as this is a very slow (but obvious) implementation
#' @param expected NumericVector, as returned by \code{\link{infection_model_indiv}}
#' @param data NumericVector, the vector of observed titres
#' @param theta NumericVector, the vector of named model parameters, requiring MAX_TITRE and error
#' @param titre_shifts NumericVector, OPTIONAL if using measurement bias, gives the shift to add to each expected titre
#' @return a single log likelihood value
#' @export
likelihood_titre_basic <- function(expected, data, theta, titre_shifts) {
    .Call('_serosolver_likelihood_titre_basic', PACKAGE = 'serosolver', expected, data, theta, titre_shifts)
}

#' Infection history gibbs proposal, fast
#'  Generates a new infection history matrix and corresponding individual likelihoods, using a gibbs sampler from the infection history prior. See \code{\link{infection_history_proposal_gibbs}}, as inputs are very similar.
#' @param theta NumericVector, the model parameters used to solve the model
#' @param infection_history_mat IntegerMatrix the matrix of 1s and 0s corresponding to individual infection histories
#' @param old_probs_1 NumericVector, the current likelihoods for each individual
#' @param sampled_indivs IntegerVector, indices of sampled individuals
#' @param n_years_samp int, for each individual, how many time periods to resample infections for?
#' @param age_mask IntegerVector, length of the number of individuals, with indices specifying first time period that an individual can be infected (indexed from 1, such that a value of 1 allows an individual to be infected in any time period)
#' @param strain_mask IntegerVector, length of the number of individuals, with indices specifying last time period that an individual can be infected (ie. last time a sample was taken)
#' @param n_alive IntegerVector, length of the number of time periods that an individual could be infected, giving the number of individual alive in each time period
#' @param swap_propn double, what proportion of proposals should be swap steps (ie. swap contents of two cells in infection_history rather than adding/removing infections)
#' @param swap_distance int, in a swap step, how many time steps either side of the chosen time period to swap with
#' @param alpha double, alpha parameter for beta prior on infection probability
#' @param beta double, beta parameter for beta prior on infection probability
#' @param circulation_times NumericVector, the times that each strain circulated
#' @param circulation_times_indices IntegerVector, indexing vector from 0:(number of strains-1)
#' @param sample_times NumericVector, the vector of real times that samples were taken
#' @param rows_per_indiv_in_samples IntegerVector, How many rows in titre data correspond to each individual, sample and repeat?
#' @param cum_nrows_per_individual_in_data IntegerVector, How many rows in the titre data correspond to each individual?
#' @param cum_nrows_per_individual_in_repeat_data IntegerVector, For the repeat data (ie. already calculated these titres), how many rows in the titre data correspond to each individual?
#' @param nrows_per_blood_sample IntegerVector, Split the sample times and runs for each individual
#' @param measurement_strain_indices IntegerVector, For each titre measurement, corresponding entry in antigenic map
#' @param antigenic_map_long NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1, see \code{\link{create_cross_reactivity_vector}}
#' @param antigenic_map_short NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2, see \code{\link{create_cross_reactivity_vector}}
#' @param data NumericVector, data for all individuals for the first instance of each calculated titre
#' @param repeat_data NumericVector, the repeat titre data for all individuals (ie. do not solve the same titres twice)
#' @param repeat_indices IntegerVector, which index in the main data vector does each entry in repeat_data correspond to ie. which calculated titre in predicted_titres should be used for each observation?
#' @param to_add Nullable<NumericVector>, optional vector of measurement shifts to apply to all titres
#' @param solve_likelihood bool, if FALSE does not solve likelihood when calculating acceptance probability
#' @param temp double, temperature for parallel tempering MCMC
#' @return an R list, one entry with the matrix of 1s and 0s corresponding to the infection histories for all individuals and the other with the new corresponding likelihoods per individual
#' @export
#' @family infection_history_proposal
infection_history_proposal_gibbs_fast <- function(theta, infection_history_mat, old_probs_1, sampled_indivs, n_years_samp_vec, age_mask, strain_mask, n_alive, swap_propn, swap_distance, alpha, beta, circulation_times, circulation_times_indices, sample_times, rows_per_indiv_in_samples, cum_nrows_per_individual_in_data, cum_nrows_per_individual_in_repeat_data, nrows_per_blood_sample, measurement_strain_indices, antigenic_map_long, antigenic_map_short, data, repeat_data, repeat_indices, titre_shifts, temp = 1, solve_likelihood = TRUE) {
    .Call('_serosolver_infection_history_proposal_gibbs_fast', PACKAGE = 'serosolver', theta, infection_history_mat, old_probs_1, sampled_indivs, n_years_samp_vec, age_mask, strain_mask, n_alive, swap_propn, swap_distance, alpha, beta, circulation_times, circulation_times_indices, sample_times, rows_per_indiv_in_samples, cum_nrows_per_individual_in_data, cum_nrows_per_individual_in_repeat_data, nrows_per_blood_sample, measurement_strain_indices, antigenic_map_long, antigenic_map_short, data, repeat_data, repeat_indices, titre_shifts, temp, solve_likelihood)
}

#' Gibbs sampling of infection histories
#'
#' Proposes a new matrix of infection histories by sampling from the prior on an individual's infection presence/absence in a particular time period, conditional on all other individuals in that time period. This allows us to integrate out the infection probability term for each time period. Should look at \code{\link{create_posterior_func}} for more details about the input parameters.
#' @param pars NumericVector, the model parameters used to solve the model, extract likelihood function parameters and alpha/beta
#' @param infection_history_mat IntegerMatrix the matrix of 1s and 0s corresponding to individual infection histories
#' @param indiv_samp_propn double, what proportion of individuals to resample in this proposal step
#' @param n_years_samp int, for each individual, how many time periods to resample infections for?
#' @param age_mask IntegerVector, length of the number of individuals, with indices specifying first time period that an individual can be infected (indexed from 1, such that a value of 1 allows an individual to be infected in any time period)
#' @param strain_mask IntegerVector, length of the number of individuals, with indices specifying last time period that an individual can be infected (ie. last time a sample was taken)
#' @param n_alive IntegerVector, length of the number of time periods that an individual could be infected, giving the number of individual alive in each time period
#' @param swap_propn double, what proportion of proposals should be swap steps (ie. swap contents of two cells in infection_history rather than adding/removing infections)
#' @param swap_distance int, in a swap step, how many time steps either side of the chosen time period to swap with
#' @param alpha double, alpha parameter for beta prior on infection probability
#' @param beta double, beta parameter for beta prior on infection probability
#' @param circulation_times NumericVector, the times that each strain circulated
#' @param circulation_times_indices IntegerVector, indexing vector from 0:(number of strains-1)
#' @param sample_times NumericVector, the vector of real times that samples were taken
#' @param rows_per_indiv_in_samples IntegerVector, How many rows in titre data correspond to each individual, sample and repeat?
#' @param cum_nrows_per_individual_in_data IntegerVector, How many rows in the titre data correspond to each individual?
#' @param nrows_per_blood_sample IntegerVector, Split the sample times and runs for each individual
#' @param measurement_strain_indices IntegerVector, For each titre measurement, corresponding entry in antigenic map
#' @param antigenic_map_long NumericVector, the collapsed cross reactivity map for long term boosting, after multiplying by sigma1
#' @param antigenic_map_short NumericVector, the collapsed cross reactivity map for short term boosting, after multiplying by sigma2
#' @param data NumericVector, the titre data for all individuals
#' @param to_add Nullable<NumericVector>, optional vector of measurement shifts to apply to all titres
#' @param additional_arguments Nullable<List>, optional list to pass down to titre solving function
#' @param DOBs NumericVector, vector of ages for each individual
#' @param solve_likelihood bool, if FALSE does not solve likelihood when calculating acceptance probability
#' @param total_alive int, if a positive number, uses this rather than the vector of alive individuals for the infection history prior
#' @param temp double, temperature for parallel tempering MCMC
#' @return a matrix of 1s and 0s corresponding to the infection histories for all individuals
#' @family infection_history_proposal
infection_history_proposal_gibbs <- function(pars, infection_history_mat, indiv_samp_propn, n_years_samp_vec, age_mask, strain_mask, n_alive, swap_propn, swap_distance, alpha, beta, circulation_times, circulation_times_indices, sample_times, rows_per_indiv_in_samples, cum_nrows_per_individual_in_data, nrows_per_blood_sample, measurement_strain_indices, antigenic_map_long, antigenic_map_short, data, to_add, additional_arguments, DOBs, solve_likelihood = TRUE, total_alive = -1L, temp = 1) {
    .Call('_serosolver_infection_history_proposal_gibbs', PACKAGE = 'serosolver', pars, infection_history_mat, indiv_samp_propn, n_years_samp_vec, age_mask, strain_mask, n_alive, swap_propn, swap_distance, alpha, beta, circulation_times, circulation_times_indices, sample_times, rows_per_indiv_in_samples, cum_nrows_per_individual_in_data, nrows_per_blood_sample, measurement_strain_indices, antigenic_map_long, antigenic_map_short, data, to_add, additional_arguments, DOBs, solve_likelihood, total_alive, temp)
}

#' Fast infection history proposal function
#' 
#' Proposes a new matrix of infection histories using a beta binomial proposal distribution. This particular implementation allows for n_infs epoch times to be changed with each function call. Furthermore, the size of the swap step is specified for each individual by move_sizes.
#' @param infection_history_mat and RcppArmadillo matrix of infection histories, where rows represent individuals and columns represent potential infection times. The contents should be a set of 1s (presence of infection) and 0s (absence of infection)
#' @param sampled_indivs IntegerVector, indices of which individuals to resample. Note that this is indexed from 1 (ie. as if passing straight from R)
#' @param age_mask IntegerVector, for each individual gives the first column in the infection history matrix that an individual could have been exposed to indexed from 1. ie. if alive for the whole period, entry would be 1. If alive for the 11th epoch, entry would be 11.
#' @param move_sizes IntegerVector, how far can a swap step sample from specified for each individual
#' @param n_infs IntegerVector, how many infections to add/remove/swap with each proposal step for each individual
#' @param alpha double, alpha parameter of the beta binomial
#' @param beta double, beta parameter of the beta binomial
#' @param rand_ns NumericVector, a vector of random numbers for each sampled individual. The idea is to pre-specify whether an individual experiences an add/remove step or a swap step to avoid random number sampling in C++
#' @return a matrix of 1s and 0s corresponding to the infection histories for all individuals
#' @export
#' @family infection_history_proposal
inf_hist_prop_cpp <- function(infection_history_mat, sampled_indivs, age_mask, strain_mask, move_sizes, n_infs, alpha, beta, rand_ns) {
    .Call('_serosolver_inf_hist_prop_cpp', PACKAGE = 'serosolver', infection_history_mat, sampled_indivs, age_mask, strain_mask, move_sizes, n_infs, alpha, beta, rand_ns)
}

#' Function to calculate non-linear waning
#'  All additional parameters for the function are declared here
#' @param theta NumericVector, the named vector of model parameters
#' @param time_infected double the time infected (sampling_time - circulation_time)
#' @return value of waning parameter based on time since infected 
#' @useDynLib serosolver
#' @export
wane_function <- function(theta, time_infected, wane) {
    .Call('_serosolver_wane_function', PACKAGE = 'serosolver', theta, time_infected, wane)
}


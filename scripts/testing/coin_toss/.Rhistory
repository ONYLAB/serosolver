print(unique_res)
count <- count + 1
}
return(count)
}
run_sim(24,8)
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
print(unique_res)
count <- count + 1
}
return(count)
}
run_sim(24,8)
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
print(unique_res)
count <- count + 1
}
return(count)
}
run_sim(24,8)
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
print(unique_res)
count <- count + 1
}
return(count)
}
run_sim(24,8)
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
print(unique_res)
count <- count + 1
}
return(count)
}
run_sim(24,8)
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
print(unique_res)
count <- count + 1
}
return(count)
}
run_sim(24,8)
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
print(unique_res)
count <- count + 1
}
return(count)
}
run_sim(24,8)
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
print(unique_res)
count <- count + 1
}
return(count)
}
run_sim(24,8)
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
count <- count + 1
}
return(count)
}
res <- NULL
for(i in 1:1000){
res <- c(res, run_sim(24,8))
}
hist(res)
mean(res)
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
count <- count + 1
}
return(count)
}
res <- NULL
for(i in 1:1000){
res <- c(res, run_sim(24,8))
}
run_sim <- function(n, m){
unique_res <- NULL
count <- 0
while(length(unique_res) < n){
res <- sample(n,m,replace=FALSE)
unique_res <- unique(c(unique_res, res))
count <- count + 1
}
return(count)
}
res <- NULL
for(i in 1:10000){
res <- c(res, run_sim(24,8))
}
hist(res)
summary(res)
density(res)
plot(density(res))
source('~/net/home/coinflip/scripts/post_analysis.R', echo=TRUE)
library(reshape2)
library(plyr)
library(ggplot2)
library(foreach)
library(doMC)
setwd("~/Documents/Fluscape/serosolver/scripts/testing/coin_toss")
devtools::load_all()
source("~/net/home/coinflip/scripts/model_funcs.R")
source("~/net/home/coinflip/scripts/probability_funcs.R")
source("~/net/home/coinflip/scripts/proposal_funcs.R")
source("~/net/home/coinflip/scripts/proposal_theta.R")
source("~/net/home/coinflip/scripts/mcmc_funcs.R")
source("~/net/home/coinflip/scripts/mcmc_funcs_gibbs.R")
library(coda)
## Input parameters
n <- 10
max_n <- 10
coin_probs <- runif(n,0,0.2)
max_indiv <- 5
indivs <- 10
samps <- seq(1,n, by=1)
pars <- c(4, 0.3, 1)
fixed <- c(0,0,0)
fixed_probs <- rep(0,n)
#fixed_probs[1:2] <- 0
covMat_theta <- diag(length(fixed[which(fixed==0)]))
covMat_probs <- diag(length(fixed_probs[which(fixed_probs==0)]))
iter <- 50000
thin <- 100
## Setup parameter names and simulated data
parNames <- c("boost","sigma","error")
coin_results <- sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE))
data_suggested_coins <- colSums(coin_results)/nrow(coin_results)
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
real_pars <- pars
real_coin_results <- coin_results
real_heads <- colSums(real_coin_results)
real_heads <- c(real_heads, sum(real_heads))
## Generate starting conditions
startPars <- pars
startPars[1] <- runif(1,0,10)
startPars[2] <- runif(1,0,1)
startPars[3] <- runif(1,0,5)
startPars[which(fixed == 1)] <- pars[which(fixed == 1)]
startProbs <- runif(n,0,1)
startProbs[which(fixed_probs == 1)] <- coin_probs[which(fixed_probs == 1)]
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE,prob = c(0.9,0.1)),nrow=indivs)
covMat_theta <- diag(length(fixed[which(fixed==0)]))
pars <- startPars
pars <- real_pars
infection_history_proposal_gibbs(pars, coin_results, 10,10,rep(1,10),rep(10,10),1,1)
coin_proposal_gibbS(pars, coin_results, dat, 1,1,1,1,1,0.5)
coin_proposal_gibbs(pars, coin_results, dat, 1,1,1,1,1,0.5)
new_coins <- start_coins
tmpStore <- NULL
for(i in 1:1000){
new_coins <- coin_proposal_gibbs(pars, new_coins, dat, 1,1,1,1,1,0.5)
infs <- colSums(newInfHist)
tmpStore <- rbind(tmpStore, infs)
}
new_coins <- start_coins
tmpStore <- NULL
for(i in 1:1000){
new_coins <- coin_proposal_gibbs(pars, new_coins, dat, 1,1,1,1,1,0.5)
infs <- colSums(new_coins)
tmpStore <- rbind(tmpStore, infs)
}
plot(as.mcmc(tmpStore))
infs <- colSums(coin_results)
names(coin_results) <- 1:n
startinfs <- colSums(start_coins)
names(startinfs) <- 1:n
inferredinfs <- apply(tmpStore,2,median)
data.frame("Infs"=infs,"Start"=startinfs,"Inferred"=inferredinfs,"Change"=inferredinfs-startinfs,"Needed change"=infs-startinfs,"Change left"=infs-inferredinfs)
n <- 100
max_n <- 10
coin_probs <- runif(n,0,0.2)
max_indiv <- 5
indivs <- 100
samps <- seq(1,n, by=1)
pars <- c(4, 0.3, 1)
fixed <- c(0,0,0)
fixed_probs <- rep(0,n)
#fixed_probs[1:2] <- 0
covMat_theta <- diag(length(fixed[which(fixed==0)]))
covMat_probs <- diag(length(fixed_probs[which(fixed_probs==0)]))
iter <- 50000
thin <- 100
## Setup parameter names and simulated data
parNames <- c("boost","sigma","error")
coin_results <- sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE))
data_suggested_coins <- colSums(coin_results)/nrow(coin_results)
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
real_pars <- pars
real_coin_results <- coin_results
real_heads <- colSums(real_coin_results)
real_heads <- c(real_heads, sum(real_heads))
## Generate starting conditions
startPars <- pars
startPars[1] <- runif(1,0,10)
startPars[2] <- runif(1,0,1)
startPars[3] <- runif(1,0,5)
startPars[which(fixed == 1)] <- pars[which(fixed == 1)]
startProbs <- runif(n,0,1)
startProbs[which(fixed_probs == 1)] <- coin_probs[which(fixed_probs == 1)]
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE,prob = c(0.9,0.1)),nrow=indivs)
covMat_theta <- diag(length(fixed[which(fixed==0)]))
pars <- startPars
pars <- real_pars
new_coins <- start_coins
tmpStore <- NULL
for(i in 1:1000){
new_coins <- coin_proposal_gibbs(pars, new_coins, dat, 1,1,1,1,1,0.5)
infs <- colSums(new_coins)
tmpStore <- rbind(tmpStore, infs)
}
infs <- colSums(coin_results)
names(coin_results) <- 1:n
startinfs <- colSums(start_coins)
names(startinfs) <- 1:n
inferredinfs <- apply(tmpStore,2,median)
data.frame("Infs"=infs,"Start"=startinfs,"Inferred"=inferredinfs,"Change"=inferredinfs-startinfs,"Needed change"=infs-startinfs,"Change left"=infs-inferredinfs)
plot(coda::as.mcmc(tmpStore))
plot(coda::as.mcmc(tmpStore))
data.frame("Infs"=infs,"Start"=startinfs,"Inferred"=inferredinfs,"Change"=inferredinfs-startinfs,"Needed change"=infs-startinfs,"Change left"=infs-inferredinfs)
pars <- startPars
pars <- real_pars
new_coins <- start_coins
tmpStore <- NULL
for(i in 1:1000){
new_coins <- coin_proposal_gibbs(pars, new_coins, dat, 1,1,1,1,1,0.5)
infs <- colSums(new_coins)
tmpStore <- rbind(tmpStore, infs)
}
infs <- colSums(coin_results)
names(coin_results) <- 1:n
startinfs <- colSums(start_coins)
names(startinfs) <- 1:n
inferredinfs <- apply(tmpStore,2,median)
data.frame("Infs"=infs,"Start"=startinfs,"Inferred"=inferredinfs,"Change"=inferredinfs-startinfs,"Needed change"=infs-startinfs,"Change left"=infs-inferredinfs)
plot(coda::as.mcmc(tmpStore))
library(reshape2)
library(plyr)
library(ggplot2)
library(foreach)
library(doMC)
setwd("~/Documents/Fluscape/serosolver/scripts/testing/coin_toss")
devtools::load_all()
source("~/net/home/coinflip/scripts/model_funcs.R")
source("~/net/home/coinflip/scripts/probability_funcs.R")
source("~/net/home/coinflip/scripts/proposal_funcs.R")
source("~/net/home/coinflip/scripts/proposal_theta.R")
source("~/net/home/coinflip/scripts/mcmc_funcs.R")
source("~/net/home/coinflip/scripts/mcmc_funcs_gibbs.R")
library(coda)
n <- 10
max_n <- 10
coin_probs <- runif(n,0,0.2)
max_indiv <- 5
indivs <- 10
samps <- seq(1,n, by=1)
pars <- c(4, 0.3, 1)
fixed <- c(0,0,0)
fixed_probs <- rep(0,n)
#fixed_probs[1:2] <- 0
covMat_theta <- diag(length(fixed[which(fixed==0)]))
covMat_probs <- diag(length(fixed_probs[which(fixed_probs==0)]))
iter <- 50000
thin <- 100
## Setup parameter names and simulated data
parNames <- c("boost","sigma","error")
coin_results <- sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE))
data_suggested_coins <- colSums(coin_results)/nrow(coin_results)
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
real_pars <- pars
real_coin_results <- coin_results
real_heads <- colSums(real_coin_results)
real_heads <- c(real_heads, sum(real_heads))
## Generate starting conditions
startPars <- pars
startPars[1] <- runif(1,0,10)
startPars[2] <- runif(1,0,1)
startPars[3] <- runif(1,0,5)
startPars[which(fixed == 1)] <- pars[which(fixed == 1)]
startProbs <- runif(n,0,1)
startProbs[which(fixed_probs == 1)] <- coin_probs[which(fixed_probs == 1)]
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE,prob = c(0.9,0.1)),nrow=indivs)
covMat_theta <- diag(length(fixed[which(fixed==0)]))
pars <- startPars
pars <- real_pars
new_coins <- start_coins
tmpStore <- NULL
for(i in 1:1000){
new_coins <- coin_proposal_gibbs(pars, new_coins, dat, 1,1,1,1,1,0.5)
infs <- colSums(new_coins)
tmpStore <- rbind(tmpStore, infs)
}
infs <- colSums(coin_results)
names(coin_results) <- 1:n
startinfs <- colSums(start_coins)
names(startinfs) <- 1:n
inferredinfs <- apply(tmpStore,2,median)
data.frame("Infs"=infs,"Start"=startinfs,"Inferred"=inferredinfs,"Change"=inferredinfs-startinfs,"Needed change"=infs-startinfs,"Change left"=infs-inferredinfs)
plot(coda::as.mcmc(tmpStore))
pars <- startPars
pars <- real_pars
new_coins <- start_coins
tmpStore <- NULL
for(i in 1:10000){
new_coins <- coin_proposal_gibbs(pars, new_coins, dat, 1,1,1,1,1,0.5)
infs <- colSums(new_coins)
tmpStore <- rbind(tmpStore, infs)
}
infs <- colSums(coin_results)
names(coin_results) <- 1:n
startinfs <- colSums(start_coins)
names(startinfs) <- 1:n
inferredinfs <- apply(tmpStore,2,median)
data.frame("Infs"=infs,"Start"=startinfs,"Inferred"=inferredinfs,"Change"=inferredinfs-startinfs,"Needed change"=infs-startinfs,"Change left"=infs-inferredinfs)
plot(coda::as.mcmc(tmpStore))
head(tmpStore)
hist(tmpStore[,1])
hist(tmpStore[,1],breaks=10)
hist(tmpStore[,2],breaks=10)
hist(tmpStore[,3],breaks=10)
quantile(tmpStore[,2],c(0.025,0.5,0.975))
quantile(tmpStore[,1],c(0.025,0.5,0.975))
library(reshape2)
library(plyr)
library(ggplot2)
library(foreach)
library(doMC)
setwd("~/Documents/Fluscape/serosolver/scripts/testing/coin_toss")
devtools::load_all()
source("~/net/home/coinflip/scripts/model_funcs.R")
source("~/net/home/coinflip/scripts/probability_funcs.R")
source("~/net/home/coinflip/scripts/proposal_funcs.R")
source("~/net/home/coinflip/scripts/proposal_theta.R")
source("~/net/home/coinflip/scripts/mcmc_funcs.R")
source("~/net/home/coinflip/scripts/mcmc_funcs_gibbs.R")
library(coda)
## Input parameters
n <- 10
max_n <- 10
coin_probs <- runif(n,0,0.2)
max_indiv <- 5
indivs <- 10
samps <- seq(1,n, by=1)
pars <- c(4, 0.3, 1)
fixed <- c(0,0,0)
fixed_probs <- rep(0,n)
#fixed_probs[1:2] <- 0
covMat_theta <- diag(length(fixed[which(fixed==0)]))
covMat_probs <- diag(length(fixed_probs[which(fixed_probs==0)]))
iter <- 50000
thin <- 100
## Setup parameter names and simulated data
parNames <- c("boost","sigma","error")
coin_results <- sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE))
data_suggested_coins <- colSums(coin_results)/nrow(coin_results)
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
real_pars <- pars
real_coin_results <- coin_results
real_heads <- colSums(real_coin_results)
real_heads <- c(real_heads, sum(real_heads))
## Generate starting conditions
startPars <- pars
startPars[1] <- runif(1,0,10)
startPars[2] <- runif(1,0,1)
startPars[3] <- runif(1,0,5)
startPars[which(fixed == 1)] <- pars[which(fixed == 1)]
startProbs <- runif(n,0,1)
startProbs[which(fixed_probs == 1)] <- coin_probs[which(fixed_probs == 1)]
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE,prob = c(0.9,0.1)),nrow=indivs)
covMat_theta <- diag(length(fixed[which(fixed==0)]))
pars <- startPars
pars <- real_pars
new_coins <- start_coins
tmpStore <- NULL
for(i in 1:10000){
new_coins <- coin_proposal_gibbs(pars, new_coins, dat, 1,1,1,1,1,0.5)
infs <- colSums(new_coins)
tmpStore <- rbind(tmpStore, infs)
}
infection_history_proposal_gibbs(pars, coin_results, 10,10,rep(1,10),rep(10,10),1,1)
res <- run_MCMC_gibbs(startPars, fixed_pars=fixed,
coin_results=start_coins,dat=dat,samps,iter=20000,covMat_theta,thin=100,rep(0.5,3),
lower_bounds=c(0,0,0),upper_bounds=c(10,1,5),
adapt_freq=500,adaptive_period=10000,printF=1000,temp=1,sampPropn=1,yearPropn=1,
theta_proposal="univariate",Z_proposal="gibbs",
alpha=1,beta=1)
plot(coda::as.mcmc(res[[2]][100:201,]))
y <- extract_number_infections_from_chain(res[[3]], n, TRUE)
plot(as.mcmc(y))
source("~/net/home/coinflip/scripts/model_funcs.R")
source("~/net/home/coinflip/scripts/probability_funcs.R")
source("~/net/home/coinflip/scripts/proposal_funcs.R")
source("~/net/home/coinflip/scripts/proposal_theta.R")
source("~/net/home/coinflip/scripts/mcmc_funcs.R")
source("~/net/home/coinflip/scripts/mcmc_funcs_gibbs.R")
library(coda)
res <- run_MCMC_gibbs(startPars, fixed_pars=fixed,
coin_results=start_coins,dat=dat,samps,iter=20000,covMat_theta,thin=100,rep(0.5,3),
lower_bounds=c(0,0,0),upper_bounds=c(10,1,5),
adapt_freq=500,adaptive_period=10000,printF=1000,temp=1,sampPropn=1,yearPropn=1,
theta_proposal="univariate",Z_proposal="gibbs",
alpha=1,beta=1)
plot(coda::as.mcmc(res[[2]][100:201,]))
pars
y <- extract_number_infections_from_chain(res[[3]], n, TRUE)
plot(as.mcmc(y))
n <- 100
max_n <- 10
coin_probs <- runif(n,0,0.2)
max_indiv <- 5
indivs <- 100
samps <- seq(1,n, by=1)
pars <- c(4, 0.3, 1)
fixed <- c(0,0,0)
fixed_probs <- rep(0,n)
#fixed_probs[1:2] <- 0
covMat_theta <- diag(length(fixed[which(fixed==0)]))
covMat_probs <- diag(length(fixed_probs[which(fixed_probs==0)]))
iter <- 50000
thin <- 100
## Setup parameter names and simulated data
parNames <- c("boost","sigma","error")
coin_results <- sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE))
data_suggested_coins <- colSums(coin_results)/nrow(coin_results)
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
real_pars <- pars
real_coin_results <- coin_results
real_heads <- colSums(real_coin_results)
real_heads <- c(real_heads, sum(real_heads))
## Generate starting conditions
startPars <- pars
startPars[1] <- runif(1,0,10)
startPars[2] <- runif(1,0,1)
startPars[3] <- runif(1,0,5)
startPars[which(fixed == 1)] <- pars[which(fixed == 1)]
startProbs <- runif(n,0,1)
startProbs[which(fixed_probs == 1)] <- coin_probs[which(fixed_probs == 1)]
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE,prob = c(0.9,0.1)),nrow=indivs)
covMat_theta <- diag(length(fixed[which(fixed==0)]))
pars <- startPars
pars <- real_pars
new_coins <- start_coins
tmpStore <- NULL
#for(i in 1:10000){
# new_coins <- coin_proposal_gibbs(pars, new_coins, dat, 1,1,1,1,1,0.5)
# infs <- colSums(new_coins)
# tmpStore <- rbind(tmpStore, infs)
#}
#infs <- colSums(coin_results)
#names(coin_results) <- 1:n
#startinfs <- colSums(start_coins)
#names(startinfs) <- 1:n
#inferredinfs <- apply(tmpStore,2,median)
#data.frame("Infs"=infs,"Start"=startinfs,"Inferred"=inferredinfs,"Change"=inferredinfs-startinfs,"Needed change"=infs-startinfs,"Change left"=infs-inferredinfs)
#plot(coda::as.mcmc(tmpStore))
#infection_history_proposal_gibbs(pars, coin_results, 10,10,rep(1,10),rep(10,10),1,1)
#source("mcmc_funcs_gibbs.R")
res <- run_MCMC_gibbs(startPars, fixed_pars=fixed,
coin_results=start_coins,dat=dat,samps,iter=20000,covMat_theta,thin=100,rep(0.5,3),
lower_bounds=c(0,0,0),upper_bounds=c(10,1,5),
adapt_freq=500,adaptive_period=10000,printF=1000,temp=1,sampPropn=1,yearPropn=1,
theta_proposal="univariate",Z_proposal="gibbs",
alpha=1,beta=1)

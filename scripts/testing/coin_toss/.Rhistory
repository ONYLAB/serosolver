print(inc_photon)
# Test difference in the survival between treatment groups
log_rank <- survdiff(Surv(stime,death) ~ treatment,data=neutron)
print(log_rank)
# Fit cox proportional hazards model
cph <- coxph(formula=Surv(stime,death) ~ treatment,data=neutron)
# View the results
summary(cph)
# Get confidence intervals for parameters
ci <- confint(cph)
# Take exponential to get intervals on the hazard scale
exp(ci)
# Set "Cervix" to the baseline group for site
neutron$site <- factor(neutron$site, levels = c("Cervix","Rectum","Bladder","Prostate"))
# Fit cox proportional hazards model with adjustments
# for site and phase
cph_adjusted <- coxph(formula=Surv(stime,death) ~ treatment + site + phase,
data=neutron)
# View the results
summary(cph_adjusted)
# Get confidence intervals for parameters
ci_adjusted <- confint(cph_adjusted)
# Take exponential to get intervals on the hazard scale
exp(ci_adjusted)
# Test the proportional hazards assumption for a cox regression model fit
s.residuals <- cox.zph(cph_adjusted)
# Look at the rest results
print(s.residuals)
# Look at log survival times
plot(survival_by_treatment,col=c("navy","red"),
fun="cloglog",
xlab="Time",
ylab="Proportion surviving")
# Add a legend to the plot
legend(col=c("navy","red"),
legend=c("Neutrons","Photons"),x="topright",
fill=c("navy","red"))
## Look at Schoenfeld residuals against time
survminer::ggcoxzph(s.residuals)
## Summary of counts for these 2 outcomes, death or metastasis
table(neutron[,c("death","meta")])
## Combined event variable. If alive and no metastasis, not of interest (=0)
## If either or both dead/metastases, of interest (=1)
neutron$metadead <- ifelse(neutron$death==0 & neutron$meta == "No",0,1)
## Find the time of the event that came first - metastasis will
## always occur first if present, and death otherwise
neutron$meta_stime <- ifelse(neutron$meta=="Yes",neutron$metatime,neutron$stime)
## Find the duration from metastasis onset to death
neutron$meta_duration <- neutron$stime - neutron$metatime
## Summary of this new variable for sense check
summary(neutron$meta_duration)
hist(neutron$meta_duration)
## Clear error with individual who apparently died before
## developing metastasis. Remove from dataset.
neutron <- neutron[neutron$meta_duration >= 0,]
par(mfrow=c(1,2))
hist(neutron[neutron$death==0,"meta_duration"],breaks=6,
xlim=c(0,600),ylim=c(0,100))
hist(neutron[neutron$death==1,"meta_duration"],breaks=6,
xlim=c(0,600),ylim=c(0,100))
par(mfrow=c(1,1))
survival_metastasis_treatment <- survfit(formula=Surv(meta_stime,metadead) ~ treatment,
data = neutron)
# Produce a Kaplan Meier plot split by group
plot(survival_metastasis_treatment,col=c("navy","red"),
xlab="Time",
ylab="Proportion surviving")
# Add a legend to the plot
legend(col=c("navy","red"),
legend=c("Neutrons","Photons"),x="topright",
fill=c("navy","red"))
## Find time at risk for each treatment group
t_neutron <- sum(neutron[neutron$treatment=="Neutrons","stime"])
## Number of events in this group
events_neutron <- sum(neutron[neutron$treatment=="Neutrons","death"])
## Incidence rate is number of events over time
inc_neutron <- events_neutron/t_neutron
print(inc_neutron)
t_photon <- sum(neutron[neutron$treatment=="Photons","stime"])
## Number of events in this group
events_photon <- sum(neutron[neutron$treatment=="Photons","death"])
## Find time at risk for each treatment group
inc_photon <- events_photon/t_photon
## Incidence rate is number of events over time
print(inc_photon)
View(neutron)
nrow(neutron)
nrow(neutron[complete.cases(neutron),])
show_solutions <- TRUE
run_chunks <- TRUE
knitr::opts_chunk$set(echo = TRUE, eval=TRUE, warnings=FALSE,
out.width = '90%', fig.align = "center")
week8dir <- "~/Documents/Teaching/msc-intro-stats/materials-2018/Week 8/"
setwd(week8dir)
neutronFile <- "neutron2.csv"
neutron <- read.csv(neutronFile,stringsAsFactors=TRUE)
neutron <- read.csv("neutron2.csv",stringsAsFactors=TRUE)
library(survival)
table(neutron$death)
survival_by_treatment <- survfit(formula=Surv(stime,death) ~ treatment,
data = neutron)
# Produce a Kaplan Meier plot split by group
plot(survival_by_treatment,col=c("navy","red"),
xlab="Time",
ylab="Proportion surviving")
# Add a legend to the plot
legend(col=c("navy","red"),
legend=c("Neutrons","Photons"),x="topright",
fill=c("navy","red"))
## Find time at risk for each treatment group
t_neutron <- sum(neutron[neutron$treatment=="Neutrons","stime"])
## Number of events in this group
events_neutron <- sum(neutron[neutron$treatment=="Neutrons","death"])
## Incidence rate is number of events over time
inc_neutron <- events_neutron/t_neutron
print(inc_neutron)
t_photon <- sum(neutron[neutron$treatment=="Photons","stime"])
## Number of events in this group
events_photon <- sum(neutron[neutron$treatment=="Photons","death"])
## Find time at risk for each treatment group
inc_photon <- events_photon/t_photon
## Incidence rate is number of events over time
print(inc_photon)
# Test difference in the survival between treatment groups
log_rank <- survdiff(Surv(stime,death) ~ treatment,data=neutron)
print(log_rank)
# Fit cox proportional hazards model
cph <- coxph(formula=Surv(stime,death) ~ treatment,data=neutron)
# View the results
summary(cph)
# Get confidence intervals for parameters
ci <- confint(cph)
# Take exponential to get intervals on the hazard scale
exp(ci)
# Set "Cervix" to the baseline group for site
neutron$site <- factor(neutron$site, levels = c("Cervix","Rectum","Bladder","Prostate"))
# Fit cox proportional hazards model with adjustments
# for site and phase
cph_adjusted <- coxph(formula=Surv(stime,death) ~ treatment + site + phase,
data=neutron)
# View the results
summary(cph_adjusted)
# Get confidence intervals for parameters
ci_adjusted <- confint(cph_adjusted)
# Take exponential to get intervals on the hazard scale
exp(ci_adjusted)
# Test the proportional hazards assumption for a cox regression model fit
s.residuals <- cox.zph(cph_adjusted)
# Look at the rest results
print(s.residuals)
# Look at log survival times
plot(survival_by_treatment,col=c("navy","red"),
fun="cloglog",
xlab="Time",
ylab="Proportion surviving")
# Add a legend to the plot
legend(col=c("navy","red"),
legend=c("Neutrons","Photons"),x="topright",
fill=c("navy","red"))
## Look at Schoenfeld residuals against time
survminer::ggcoxzph(s.residuals)
neutron
any(is.na(neutron))
neutron[!complete.cases(neutron),]
View(neutron)
range(neutron$meta_duration)
table(neutron[,c("death","meta")])
neutron$metadead <- ifelse(neutron$death==0 & neutron$meta == "No",0,1)
neutron$meta_stime <- ifelse(neutron$meta=="Yes",neutron$metatime,neutron$stime)
neutron$meta_duration <- neutron$stime - neutron$metatime
summary(neutron$meta_duration)
hist(neutron$meta_duration)
show_solutions <- TRUE
run_chunks <- TRUE
knitr::opts_chunk$set(echo = TRUE, eval=TRUE, warnings=FALSE,
out.width = '90%', fig.align = "center")
week8dir <- "~/Documents/Teaching/msc-intro-stats/materials-2018/Week 8/"
setwd(week8dir)
neutronFile <- "neutron2.csv"
neutron <- read.csv(neutronFile,stringsAsFactors=TRUE)
neutron <- read.csv("neutron2.csv",stringsAsFactors=TRUE)
library(survival)
table(neutron$death)
survival_by_treatment <- survfit(formula=Surv(stime,death) ~ treatment,
data = neutron)
# Produce a Kaplan Meier plot split by group
plot(survival_by_treatment,col=c("navy","red"),
xlab="Time",
ylab="Proportion surviving")
# Add a legend to the plot
legend(col=c("navy","red"),
legend=c("Neutrons","Photons"),x="topright",
fill=c("navy","red"))
## Find time at risk for each treatment group
t_neutron <- sum(neutron[neutron$treatment=="Neutrons","stime"])
## Number of events in this group
events_neutron <- sum(neutron[neutron$treatment=="Neutrons","death"])
## Incidence rate is number of events over time
inc_neutron <- events_neutron/t_neutron
print(inc_neutron)
t_photon <- sum(neutron[neutron$treatment=="Photons","stime"])
## Number of events in this group
events_photon <- sum(neutron[neutron$treatment=="Photons","death"])
## Find time at risk for each treatment group
inc_photon <- events_photon/t_photon
## Incidence rate is number of events over time
print(inc_photon)
# Test difference in the survival between treatment groups
log_rank <- survdiff(Surv(stime,death) ~ treatment,data=neutron)
print(log_rank)
# Fit cox proportional hazards model
cph <- coxph(formula=Surv(stime,death) ~ treatment,data=neutron)
# View the results
summary(cph)
# Get confidence intervals for parameters
ci <- confint(cph)
# Take exponential to get intervals on the hazard scale
exp(ci)
# Set "Cervix" to the baseline group for site
neutron$site <- factor(neutron$site, levels = c("Cervix","Rectum","Bladder","Prostate"))
# Fit cox proportional hazards model with adjustments
# for site and phase
cph_adjusted <- coxph(formula=Surv(stime,death) ~ treatment + site + phase,
data=neutron)
# View the results
summary(cph_adjusted)
# Get confidence intervals for parameters
ci_adjusted <- confint(cph_adjusted)
# Take exponential to get intervals on the hazard scale
exp(ci_adjusted)
# Test the proportional hazards assumption for a cox regression model fit
s.residuals <- cox.zph(cph_adjusted)
# Look at the rest results
print(s.residuals)
# Look at log survival times
plot(survival_by_treatment,col=c("navy","red"),
fun="cloglog",
xlab="Time",
ylab="Proportion surviving")
# Add a legend to the plot
legend(col=c("navy","red"),
legend=c("Neutrons","Photons"),x="topright",
fill=c("navy","red"))
## Look at Schoenfeld residuals against time
survminer::ggcoxzph(s.residuals)
## Summary of counts for these 2 outcomes, death or metastasis
table(neutron[,c("death","meta")])
## Combined event variable. If alive and no metastasis, not of interest (=0)
## If either or both dead/metastases, of interest (=1)
neutron$metadead <- ifelse(neutron$death==0 & neutron$meta == "No",0,1)
## Find the time of the event that came first - metastasis will
## always occur first if present, and death otherwise
neutron$meta_stime <- ifelse(neutron$meta=="Yes",neutron$metatime,neutron$stime)
## Find the duration from metastasis onset to death
neutron$meta_duration <- neutron$stime - neutron$metatime
## Summary of this new variable for sense check
summary(neutron$meta_duration)
hist(neutron$meta_duration)
## Clear error with individual who apparently died before
## developing metastasis. Remove from dataset.
neutron <- neutron[neutron$meta_duration >= 0,]
neutron <- neutron[complete.cases(neutron),]
par(mfrow=c(1,2))
hist(neutron[neutron$death==0,"meta_duration"],breaks=6,
xlim=c(0,600),ylim=c(0,100))
hist(neutron[neutron$death==1,"meta_duration"],breaks=6,
xlim=c(0,600),ylim=c(0,100))
par(mfrow=c(1,1))
survival_metastasis_treatment <- survfit(formula=Surv(meta_stime,metadead) ~ treatment,
data = neutron)
# Produce a Kaplan Meier plot split by group
plot(survival_metastasis_treatment,col=c("navy","red"),
xlab="Time",
ylab="Proportion surviving")
# Add a legend to the plot
legend(col=c("navy","red"),
legend=c("Neutrons","Photons"),x="topright",
fill=c("navy","red"))
## Find time at risk for each treatment group
t_neutron <- sum(neutron[neutron$treatment=="Neutrons","stime"])
## Number of events in this group
events_neutron <- sum(neutron[neutron$treatment=="Neutrons","death"])
## Incidence rate is number of events over time
inc_neutron <- events_neutron/t_neutron
print(inc_neutron)
t_photon <- sum(neutron[neutron$treatment=="Photons","stime"])
## Number of events in this group
events_photon <- sum(neutron[neutron$treatment=="Photons","death"])
## Find time at risk for each treatment group
inc_photon <- events_photon/t_photon
## Incidence rate is number of events over time
print(inc_photon)
## Find time at risk for each treatment group
t_neutron <- sum(neutron[neutron$treatment=="Neutrons","stime"])
## Number of events in this group
events_neutron <- sum(neutron[neutron$treatment=="Neutrons","metadead"])
## Incidence rate is number of events over time
inc_neutron <- events_neutron/t_neutron
print(inc_neutron)
## Find time at risk for each treatment group
t_photon <- sum(neutron[neutron$treatment=="Photons","stime"])
## Number of events in this group
events_photon <- sum(neutron[neutron$treatment=="Photons","metadead"])
## Find time at risk for each treatment group
inc_photon <- events_photon/t_photon
## Incidence rate is number of events over time
print(inc_photon)
# Fit cox proportional hazards model with adjustments
# for site and phase
cph_metadead <- coxph(formula=Surv(stime,metadead) ~ treatment + site + phase,
data=neutron)
# View the results
summary(cph_metadead)
# Get confidence intervals for parameters
cph_metadead <- confint(cph_metadead)
# Take exponential to get intervals on the hazard scale
exp(cph_metadead)
1 - 0.7155
q2_table <- read.csv("q2_table.csv")
knitr::kable(q2_table)
q2_table <- read.csv("q2_table.csv")
knitr::kable(q2_table)
colnames(q2_table)[1] <- "Variable"
knitr::kable(q2_table)
survminer::ggcoxzph(s.residuals) + theme(text=element_text(size=8))
?ggcox\ph
?ggcoxzph
survminer::ggcoxzph(s.residuals,ncol=1)
survminer::ggcoxzph(s.residuals,ncol=1)
survminer::ggcoxzph(s.residuals) + ggpar(font.x=6)
survminer::ggcoxzph(s.residuals,font.x=6)
survminer::ggcoxzph(s.residuals,font.main=6)
survminer::ggcoxzph(s.residuals,font.main=8,font.x=8,font.y=8)
survminer::ggcoxzph(s.residuals,font.main=8,font.x=8,font.y=8,font.tickslab=8)
install.packages("kableExtra")
library(kableExtra)
?column_spec
?kable
library(reshape2)
library(plyr)
library(ggplot2)
library(foreach)
library(doMC)
library(coda)
registerDoMC(5)  #change the 2 to your number of CPU cores
getDoParWorkers()
setwd("~/Documents/Fluscape/serosolver/scripts/testing/coin_toss")
source("model_funcs.R")
source("probability_funcs.R")
source("proposal_funcs.R")
source("proposal_theta.R")
source("mcmc_funcs.R")
source("mcmc_funcs_marginal.R")
n <- 50
coin_probs <- runif(n,0,0.2)
indivs <- 50
samps <- seq(1,n, by=1)
pars <- c(4, 0.2, 1)
fixed <- c(0,0,0)
fixed_probs <- rep(0,n)
covMat_theta <- diag(length(fixed[which(fixed==0)]))
covMat_probs <- diag(length(fixed_probs[which(fixed_probs==0)]))
iter <- 50000
parNames <- c("boost","sigma","error")
coin_results <- sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE))
data_suggested_coins <- colSums(coin_results)/nrow(coin_results)
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
print(paste0("Coin probs: ", paste0(signif(coin_probs,3),collapse=" ")))
print(paste0("Data suggest coin values: ", paste0(data_suggested_coins,collapse=" ")))
chains <- foreach(i=1:5) %dopar% {
startPars <- pars
startPars[1] <- runif(1,0,10)
startPars[2] <- runif(1,0,1)
startPars[3] <- runif(1,0,5)
startPars[which(fixed == 1)] <- pars[which(fixed == 1)]
startProbs <- runif(n,0,1)
startProbs[which(fixed_probs == 1)] <- coin_probs[which(fixed_probs == 1)]
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE,prob = c(0.9,0.1)),nrow=indivs)
#res <- run_MCMC_marginal(startPars, fixed, start_coins,dat,samps, iter,
#                          covMat_theta, thin=100,0.01,1000,20000,
#                          printF=1000,temp=1, samplePropn=0.1, yearPropn=0.2)
res <- run_MCMC_group(startPars, startProbs,
fixed, fixed_probs,
start_coins,dat,samps, iter,
covMat_theta, covMat_probs, thin=100,
step_theta=rep(0.01,length(startPars)),step_prob=rep(0.001,length(startProbs)),
adapt_freq=10000,adaptive_period=20000,
printF=1000,temp=1,
sampPropn=0.1,
yearPropn=0.1)
chain <- res[[2]]
as.mcmc(chain)
}
res1 <- run_MCMC_group(startPars, startProbs, fixed, fixed_probs, coin_results,dat,samps, iter,
covMat_theta, covMat_probs, thin=100,0.01,0.001,500,1,printF=1000,temp=3)
startPars <- pars
startPars[1] <- runif(1,0,10)
startPars[2] <- runif(1,0,1)
startPars[3] <- runif(1,0,5)
startPars[which(fixed == 1)] <- pars[which(fixed == 1)]
startProbs <- runif(n,0,1)
startProbs[which(fixed_probs == 1)] <- coin_probs[which(fixed_probs == 1)]
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE,prob = c(0.9,0.1)),nrow=indivs)
res1 <- run_MCMC_group(startPars, startProbs, fixed, fixed_probs, coin_results,dat,samps, iter,
covMat_theta, covMat_probs, thin=100,0.01,0.001,500,1,printF=1000,temp=3)
?adaptive_period
?run_MCMC_group
chains <- foreach(i=1:5) %dopar% {
startPars <- pars
startPars[1] <- runif(1,0,10)
startPars[2] <- runif(1,0,1)
startPars[3] <- runif(1,0,5)
startPars[which(fixed == 1)] <- pars[which(fixed == 1)]
startProbs <- runif(n,0,1)
startProbs[which(fixed_probs == 1)] <- coin_probs[which(fixed_probs == 1)]
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE,prob = c(0.9,0.1)),nrow=indivs)
#res <- run_MCMC_marginal(startPars, fixed, start_coins,dat,samps, iter,
#                          covMat_theta, thin=100,0.01,1000,20000,
#                          printF=1000,temp=1, samplePropn=0.1, yearPropn=0.2)
res <- run_MCMC_group(startPars, startProbs,
fixed, fixed_probs,
start_coins,dat,samps, iter,
covMat_theta, covMat_probs, thin=100,
step_theta=rep(0.01,length(startPars)),step_prob=rep(0.001,length(startProbs)),
adapt_freq=10000,adaptive_period=20000,
printF=1000,temp=1,
sampPropn=0.1,
yearPropn=0.1)
chain <- res[[2]]
as.mcmc(chain)
}
covMat_theta <- diag(length(fixed[which(fixed==0)]))
covMat_probs <- diag(length(fixed_probs[which(fixed_probs==0)]))
chains <- foreach(i=1:5) %dopar% {
startPars <- pars
startPars[1] <- runif(1,0,10)
startPars[2] <- runif(1,0,1)
startPars[3] <- runif(1,0,5)
startPars[which(fixed == 1)] <- pars[which(fixed == 1)]
startProbs <- runif(n,0,1)
startProbs[which(fixed_probs == 1)] <- coin_probs[which(fixed_probs == 1)]
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE,prob = c(0.9,0.1)),nrow=indivs)
#res <- run_MCMC_marginal(startPars, fixed, start_coins,dat,samps, iter,
#                          covMat_theta, thin=100,0.01,1000,20000,
#                          printF=1000,temp=1, samplePropn=0.1, yearPropn=0.2)
res <- run_MCMC_group(startPars, startProbs,
fixed, fixed_probs,
start_coins,dat,samps, iter,
covMat_theta, covMat_probs, thin=100,
step_theta=rep(0.01,length(startPars)),step_prob=rep(0.001,length(startProbs)),
adapt_freq=10000,adaptive_period=20000,
printF=1000,temp=1,
sampPropn=0.1,
yearPropn=0.1)
chain <- res[[2]]
as.mcmc(chain)
}
res <- run_MCMC_group(startPars, startProbs,
fixed, fixed_probs,
start_coins,dat,samps, iter,
covMat_theta=covMat_theta, covMat_probs, thin=100,
step_theta=rep(0.01,length(startPars)),step_prob=rep(0.001,length(startProbs)),
adapt_freq=10000,adaptive_period=20000,
printF=1000,temp=1,
sampPropn=0.1,
yearPropn=0.1)
res <- run_MCMC_group(startPars, startProbs,
fixed, fixed_probs,
start_coins,dat,samps, iter,
covMat_theta=covMat_theta, covMat_probs=covMat_probs, thin=100,
step_theta=rep(0.01,length(startPars)),step_prob=rep(0.001,length(startProbs)),
adapt_freq=10000,adaptive_period=20000,
printF=1000,temp=1,
sampPropn=0.1,
yearPropn=0.1)
n <- 3
coin_probs <- runif(n,0,0.2)
indivs <- 200
samps <- seq(1,n, by=1)
coin_results <- sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE))
iter <- 10000
tmp <- matrix(nrow=iter,ncol=ncol(coin_results))
tmp_coin_results <- coin_results
lambdas <- runif(iter)
p_lambda <- numeric(iter)
N <- indivs
alpha <- beta <- 1
for(i in 1:iter){
#tmp_coin_results <- coin_proposal_probs(tmp_coin_results, coin_probs, n, indivs)
tmp_coin_results <- coin_proposal_gibbs(tmp_coin_results, 1000, 1000)
tmp[i,] <- colSums(tmp_coin_results)
x <- sum(tmp_coin_results[,1])
lambdas[i] <- rbeta(1, alpha + x, beta + N - x)
#p_lambda[i] <- prod((lambdas[i])^tmp_coin_results[,1] *(1-lambdas[i])^tmp_coin_results[,1])*dbeta(lambdas[i],1,1)/(beta(x + alpha, N - x + beta)/beta(alpha, beta))
#prod((lambdas[i])^tmp_coin_results[,1] *(1-lambdas[i])^tmp_coin_results[,1])*dbeta(lambdas[i],1,1)/(beta(x + alpha, N - x + beta)/beta(alpha, beta))
#/exp(inf_mat_prior(tmp_coin_results, 1,1))
}
#plot(density(rbinom(10000,indivs,0.5)))
plot(density(tmp[,1]/indivs),col="red")
plot(density(lambdas))
coin_proposal_gibbs
for(i in 1:iter){
#tmp_coin_results <- coin_proposal_probs(tmp_coin_results, coin_probs, n, indivs)
tmp_coin_results <- coin_proposal_gibbs(tmp_coin_results, 1000, 1000)
tmp[i,] <- colSums(tmp_coin_results)
x <- sum(tmp_coin_results[,1])
lambdas[i] <- rbeta(1, alpha + x, beta + N - x)
#p_lambda[i] <- prod((lambdas[i])^tmp_coin_results[,1] *(1-lambdas[i])^tmp_coin_results[,1])*dbeta(lambdas[i],1,1)/(beta(x + alpha, N - x + beta)/beta(alpha, beta))
#prod((lambdas[i])^tmp_coin_results[,1] *(1-lambdas[i])^tmp_coin_results[,1])*dbeta(lambdas[i],1,1)/(beta(x + alpha, N - x + beta)/beta(alpha, beta))
#/exp(inf_mat_prior(tmp_coin_results, 1,1))
}

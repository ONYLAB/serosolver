}
infHists5 <- as.data.frame(infHists5)
colnames(infHists5) <- c(1:10, "indiv","samp","ver")
infHists5[,13] <- "binom_bb"
omgs5$ver <- "binom_bb"
#infHists_comb <- as.data.frame(rbind(infHists,infHists1, infHists2, infHists3, infHists4, infHists5))
infHists_comb <- infHists5[complete.cases(infHists5),]
greb <- melt(infHists_comb, id.vars=c("ver","samp","indiv"))
AR1 <- ddply(greb, .(variable, ver, samp), function(x) sum(x$value))
res <- ddply(AR1, .(variable,ver), function(x) quantile(x$V1,c(0.025,0.5,0.975)))
res <- res[order(res$ver,res$variable),]
n_alive <- sapply(strainIsolationTimes, function(x) length(ageMask[ageMask <=x]))
res[,3] <- res[,3]/rep(n_alive,1)
res[,4] <- res[,4]/rep(n_alive,1)
res[,5] <- res[,5]/rep(n_alive,1)
ggplot(res) + geom_pointrange(aes(x=variable,y=`50%`,ymax=`97.5%`,ymin=`2.5%`)) + facet_wrap(~ver) + scale_y_continuous(limits=c(0,1))
infHists_comb <- as.data.frame(rbind(infHists,infHists1, infHists2, infHists3, infHists4, infHists5))
greb <- melt(infHists_comb, id.vars=c("ver","samp","indiv"))
AR1 <- ddply(greb, .(variable, ver, samp), function(x) sum(x$value))
res <- ddply(AR1, .(variable,ver), function(x) quantile(x$V1,c(0.025,0.5,0.975)))
res <- res[order(res$ver,res$variable),]
n_alive <- sapply(strainIsolationTimes, function(x) length(ageMask[ageMask <=x]))
res[,3] <- res[,3]/rep(n_alive,1)
res[,4] <- res[,4]/rep(n_alive,1)
res[,5] <- res[,5]/rep(n_alive,1)
ggplot(res) + geom_pointrange(aes(x=variable,y=`50%`,ymax=`97.5%`,ymin=`2.5%`)) + facet_wrap(~ver) + scale_y_continuous(limits=c(0,1))
omgs$ver <- "AK"
omgs2$ver <- "AK_mine"
omgs3$ver <- "BB_cpp"
omgs4$ver <- "symmetric"
wow <- rbind(omgs, omgs1, omgs2, omgs3, omgs4, omgs5)
#wow <- omgs5
indiv_total <- ggplot(wow[wow$indiv %in% which(ageMask >= 5),]) + geom_histogram(aes(x=infs,fill=ver),binwidth=1) +
#facet_grid(ver~indiv) +
facet_wrap(~indiv)+
scale_x_continuous(expand=c(0,0),
limits=c(0,10),labels=seq(0,10,by=2),breaks=seq(0,10,by=2))
ncol(omgs)
ncol(omgs1)
ncol(omgs2)
ncol(omgs3)
ncol(omgs4)
head(omgs1)
head(omgs)
omgs1$ver <- "beta_binom"
omgs2$ver <- "AK_mine"
omgs3$ver <- "BB_cpp"
omgs4$ver <- "symmetric"
wow <- rbind(omgs, omgs1, omgs2, omgs3, omgs4, omgs5)
indiv_total <- ggplot(wow[wow$indiv %in% which(ageMask >= 5),]) + geom_histogram(aes(x=infs,fill=ver),binwidth=1) +
#facet_grid(ver~indiv) +
facet_wrap(~indiv)+
scale_x_continuous(expand=c(0,0),
limits=c(0,10),labels=seq(0,10,by=2),breaks=seq(0,10,by=2))
indiv_total
indiv_total <- ggplot(wow[wow$indiv %in% which(ageMask >= 5),]) + geom_histogram(aes(x=infs,fill=ver),binwidth=1) +
facet_grid(ver~indiv) +
#facet_wrap(~indiv)+
scale_x_continuous(expand=c(0,0),
limits=c(0,10),labels=seq(0,10,by=2),breaks=seq(0,10,by=2))
indiv_total
for(var in unique(AR1$variable)){
AR1[AR1$variable == var, "V1"] <- AR1[AR1$variable == var, "V1"]/n_alive[as.numeric(var)]
}
AR_densities <- ggplot(AR1) +
geom_density(aes(x=V1)) +
#scale_x_continuous(limits=c(0,1))+
#scale_x_continuous(breaks=seq(0,1,by=0.2),labels=seq(0,1,by=0.2)) +
facet_grid(ver~variable) +
theme_bw()
AR_densities
n_alive
head(AR1)
AR1 <- ddply(greb, .(variable, ver, samp), function(x) sum(x$value))
AR_densities <- ggplot(AR1) +
geom_density(aes(x=V1)) +
#scale_x_continuous(limits=c(0,1))+
scale_x_continuous(breaks=seq(0,1,by=0.2),labels=seq(0,1,by=0.2)) +
facet_grid(ver~variable) +
theme_bw()
AR_densities
AR1 <- ddply(greb, .(variable, ver, samp), function(x) sum(x$value))
for(var in unique(AR1$variable)){
AR1[AR1$variable == var, "V1"] <- AR1[AR1$variable == var, "V1"]/n_alive[as.numeric(var)]
}
AR_densities <- ggplot(AR1) +
geom_density(aes(x=V1)) +
#scale_x_continuous(limits=c(0,1))+
scale_x_continuous(breaks=seq(0,1,by=0.2),labels=seq(0,1,by=0.2)) +
facet_grid(ver~variable) +
theme_bw()
AR_densities
AR_densities <- ggplot(AR1) +
geom_density(aes(x=V1)) +
#scale_x_continuous(limits=c(0,1))+
scale_x_continuous(limits=c(0,1),breaks=seq(0,1,by=0.2),labels=seq(0,1,by=0.2)) +
facet_grid(ver~variable) +
theme_bw()
AR_densities
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_group.R', echo=TRUE)
p1
p2
p3
p2
p3
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_group.R', echo=TRUE)
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_group.R', echo=TRUE)
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_group.R', echo=TRUE)
p1
p2
p3
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_group.R', echo=TRUE)
p1
p2
p3
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_group.R', echo=TRUE)
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_group.R', echo=TRUE)
p1
p3
foi_proposal <- function(fois, infMat, is, alpha, beta, n){
proposed <- fois
if(length(is) > 1){
infs <- colSums(infMat[,is])
proposed[is] <- rbeta(length(is), alpha+infs, beta + n[is]-infs)
} else {
infs <- sum(infMat[,years])
proposed[is] <- rbeta(1, alpha+infs, beta + n[is]-infs)
}
forward <- sum(dbeta(proposed[is], alpha,beta,log=TRUE))
back <- sum(dbeta(fois[is],alpha,beta,log=TRUE))
ratio <- back - forward
return(list(proposed,ratio))
}
coin_probs
coin_results
foi_proposal(coin_probs, coin_results, 1:10, 1,1,indivs)
indivs
foi_proposal(coin_probs, coin_results, 1:10, 1,1,rep(indivs,10)
)
indivs
n
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
foi_proposal(coin_probs, coin_results, 1:n, 1,1,rep(indivs,n))
source('~/.active-rstudio-document', echo=TRUE)
omg <- matrix(nrow=1000,ncol=n)
for(i in 1:1000{
omg[i,] <- foi_proposal(coin_probs, coin_results, 1:n,1,1,rep(indivs,n))
}
for(i in 1:1000){
omg[i,] <- foi_proposal(coin_probs, coin_results, 1:n,1,1,rep(indivs,n))
}
hist(omg[,1])
hist(omg[,2])
colSums(coin_results[,1])
sum(coin_results[,1])
indivs
coin_probs[1]
coin_probs
hist(omg[,3])
hist(omg[,4])
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_indiv_correct.R', echo=TRUE)
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_indiv_correct.R', echo=TRUE)
iter
iter/100
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_indiv_correct.R', echo=TRUE)
nrow(coin_results)
prob_flips
start_coins
fixed
coin_probs
res <- run_MCMC_group(pars, fixed, dat, start_coins,coin_probs,iter, covMat,thin=10)
chain <- res[[2]]
chain <- chain[,which(fixed == 0)+1]
colnames(chain) <- parNames[which(fixed==0)]
chain <- melt(chain)
colnames(chain) <- c("x","parameter","value")
real_pars <- data.frame(parameter=parNames[which(fixed==0)],y=pars[which(fixed==0)])
p1 <- ggplot(chain) +
geom_density(aes(x=value,y=..scaled..)) +
geom_vline(data=real_pars,aes(xintercept=y),col="red",linetype="dashed")+
facet_wrap(~parameter, scales="free_x")
p1
p2
head(chain)
head(res[[1]])
head(res[[2]])
coin_chain <- as.data.frame(res[[3]])
colnames(coin_chain) <- c("sampno",1:n,"indiv")
allRes <- NULL
for(j in 1:10){
print(j)
x <- NULL
i <- 1
for(sampno in unique(coin_chain$sampno)){
tmpChain <- coin_chain[coin_chain$sampno == sampno,]
x[i] <- sum(tmpChain[,colnames(tmpChain) == j])/indivs
i <- i+ 1
}
final <- quantile(x,c(0.025,0.5,0.975))
allRes <- rbind(allRes, final)
}
tmp <- melt(coin_chain[,1:(ncol(coin_chain)-1)], id.vars="sampno")
tmp <- ddply(tmp, .(sampno, variable), function(x) sum(x$value)/indivs)
tmp <- ddply(tmp, ~variable, function(x) quantile(x$V1, c(0.025,0.5,0.975)))
inferred_coins <- plyr::ddply(coin_chain, ~indiv, colMeans)
inferred_coins <- inferred_coins[,2:ncol(inferred_coins)]
wow <- melt(inferred_coins,id.vars="indiv")
omg <- melt(coin_results)
colnames(omg) <- c("indiv","variable","value")
omg <- omg[omg$value == 1,]
p2 <- ggplot(wow[wow$indiv %in% 1:10,]) +
geom_point(aes(x=variable,y=value)) +
geom_vline(data=omg[omg$indiv %in% 1:10,],aes(xintercept=variable),col="red",linetype="dashed",alpha=0.4) +
facet_wrap(~indiv)
p2
real_coins <- data.frame(variable=1:n, y=coin_probs)
p3 <- ggplot(tmp) +
geom_pointrange(aes(x=variable,ymin=`2.5%`,y=`50%`,ymax=`97.5%`)) +
geom_point(data=real_coins, aes(x=variable,y=y),col="red") +
scale_y_continuous(limits=c(0,1))
p3
n <- 10
indivs <- 10
coin_probs <- matrix(runif(n*indivs),nrow=indivs)
pars <- c(4, 0.3, 0.1, coin_probs)
parNames <- c("boost","sigma","error",paste0("coin.",1:n))
coin_results <- matrix(sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE)),nrow=indivs)
data_suggested_coins <- colSums(coin_results)/nrow(coin_results)
print(paste0("Coin probs: ", paste0(signif(coin_probs,3),collapse=" ")))
print(paste0("Data suggest coin values: ", paste0(data_suggested_coins,collapse=" ")))
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
coin_probs
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
fixed <- c(1,1,1,rep(0,n))
covMat <- diag(length(fixed[which(fixed==0)]))*0.01
iter <- 5000
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE),nrow=indivs)
pars
n <- 10
indivs <- 10
coin_probs <- matrix(runif(n*indivs),nrow=indivs)
pars <- c(4, 0.3, 0.1)
parNames <- c("boost","sigma","error",paste0("coin.",1:n))
coin_results <- matrix(sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE)),nrow=indivs)
data_suggested_coins <- colSums(coin_results)/nrow(coin_results)
print(paste0("Coin probs: ", paste0(signif(coin_probs,3),collapse=" ")))
print(paste0("Data suggest coin values: ", paste0(data_suggested_coins,collapse=" ")))
dat <- coin_toss_group(pars, coin_results)
## We have
coin_toss_group <- function(pars, coin_results){
indivs <- nrow(coin_results)
y <- apply(coin_results, 1, function(x) coin_toss_function(pars, x))
return(y)
}
coin_toss_function <- function(pars, coin_results){
mu <- pars[1]
sigma <- pars[2]
res <- numeric(length(coin_results))
for(toss in seq_along(coin_results)){
## Boost to actual coin
res[toss] <- res[toss] + mu*coin_results[toss]
## Boost to adjacent coins
adjacent_toss <- c(toss + 1, toss - 1)
adjacent_toss <- adjacent_toss[adjacent_toss > 0 & adjacent_toss <= length(res)]
res[adjacent_toss] <- res[adjacent_toss] + sigma*mu*coin_results[toss]
}
return(res)
}
measurement_error_group <- function(pars, dat){
error <- pars[3]
dat <- apply(dat, 1, function(x) rnorm(length(x), x, error))
return(dat)
}
likelihood <- function(pars, coin_results, dat){
y <- coin_toss_function(pars, coin_results)
return(sum(dnorm(dat, mean=y, sd=pars[3],log=TRUE)))
}
likelihood_group <- function(pars, coin_results, dat){
y <- coin_toss_group(pars, coin_results)
liks <- numeric(nrow(dat))
for(i in 1:nrow(y)){
liks[i] <- likelihood(pars, coin_results[i,],dat[i,])
}
return(liks)
}
hyper_prior_group <- function(pars, coin_results){
flip_probs <- pars[4:length(pars)]
#return(rep(0, length(flip_probs)))
prob <- apply(coin_results, 1, function(x) sum(log(flip_probs^x * (1-flip_probs)^(1-x))))
return(prob)
}
prior <- function(pars){
a <- dnorm(pars[1], 0, 1000,log=TRUE)
b <- dnorm(pars[1],0,1000,log=TRUE)
#c <- 0
c <- sum(dbeta(pars[4:length(pars)], 1,1,log=TRUE))
return(a+b+c)
}
posterior_group <- function(pars, coin_results, dat){
return(sum(likelihood_group(pars, coin_results, dat)) + hyper_prior_group(pars, coin_results) + prior(pars))
}
proposal_theta <- function(pars, fixed, covMat, covMat0, beta=0.05){
proposed <- pars
proposed[fixed] <- (1-beta)*MASS::mvrnorm(n=1,mu=proposed[fixed], Sigma=5.6644*covMat/length(fixed)) +
beta*MASS::mvrnorm(n=1,mu=proposed[fixed], Sigma=0.001*covMat0/length(fixed))
return(proposed)
}
coin_proposal <- function(coin_results, k=1){
#proposed <- sample(c(0,1),length(coin_results),replace=TRUE)
locs <- sample(length(coin_results),k)
proposed <- coin_results
proposed[locs] <- !coin_results[locs]
return(proposed)
}
coin_proposal_symmetric_group <- function(coin_results, k=1, indivs=1){
proposed <- coin_results
for(j in indivs){
if(runif(1) < 0.5){
locs <- sample(length(coin_results[j,]), k)
proposed[j,locs] <- !coin_results[j,locs]
} else {
locs <- sample(length(coin_results[j,]),2)
loc1 <- locs[1]
loc2 <- locs[2]
tmp <- proposed[j,loc1]
proposed[j,loc1] <- proposed[j,loc2]
proposed[j,loc2] <- tmp
}
}
return(proposed)
}
run_MCMC_group <- function(pars, fixed, dat, coin_results, probs_flip, iter,covMat, thin=10){
n_indiv <- nrow(coin_results)
liks <- numeric(iter/thin)
chain <- matrix(nrow=iter/thin,ncol=length(pars)+1)
coin_chain <- matrix(nrow=iter*n_indiv/thin,ncol=ncol(coin_results)+2)
probs_chain <- matrix(nrow=iter*n_indiv/thin,ncol=ncol(probs_flip)+2)
proposed <- pars
proposed_coin_results <- coin_results
probabs <- posterior_group(pars, coin_results, dat)
probab <- sum(probabs)
liks[1] <- probab
chain[1,1] <- 1
chain[1,2:ncol(chain)] <- pars
coin_chain[1:n_indiv,1] <- 1
coin_chain[1:n_indiv,2:(ncol(coin_chain)-1)] <- coin_results
coin_chain[1:n_indiv,ncol(coin_chain)] <- 1:n_indiv
accepted_theta <- iter_theta <- 0
accepted_coin <- iter_coin <- numeric(n_indiv)
fixed <- which(fixed == 0)
index <- 1
for(i in 2:iter){
if(i %% thin == 0) message(i)
if(i %% 2 == 0){
proposed <- proposal_theta(pars, fixed, covMat, covMat)
iter_theta <- iter_theta + 1
new_probabs <- likelihood_group(proposed, coin_results, dat) + hyper_prior_group(pars, coin_results)
new_probab <- sum(new_probabs) + prior(proposed)
log_prob <- min(new_probab - probab,0)
if(is.finite(log_prob) & log(runif(1))<log_prob){
pars <- proposed
probab <- new_probab
probabs <- new_probabs
accepted_theta <- accepted_theta + 1
}
} else {
sampledI <- 1:n_indiv
proposed_coin_results <- coin_proposal_symmetric_group(coin_results,1,sampledI)
new_probabs <- likelihood_group(pars, proposed_coin_results, dat) + hyper_prior_group(pars, proposed_coin_results)
iter_coin[sampledI] <- iter_coin[sampledI] + 1
log_probs <- new_probabs[sampledI] - probabs[sampledI]
log_probs[log_probs > 0] <- 0
x <- which(log(runif(length(sampledI))) < log_probs)
changeI <- sampledI[x]
coin_results[changeI,] <- proposed_coin_results[changeI,]
accepted_coin[changeI] <- accepted_coin[changeI] + 1
probabs[changeI] <- new_probabs[changeI]
probab <- sum(probabs) + prior(proposed)
}
if(i %% thin == 0){
liks[index] <- probab
chain[index,1] <- i
chain[index,2:ncol(chain)] <- pars
coin_chain[((index-1)*n_indiv + 1):(index*n_indiv),1] <- i
coin_chain[((index-1)*n_indiv + 1):(index*n_indiv),2:(ncol(coin_chain)-1)] <- coin_results
coin_chain[((index-1)*n_indiv + 1):(index*n_indiv),ncol(coin_chain)] <- 1:n_indiv
index <- index + 1
}
}
message(paste0("Acceptance rate on theta: ", accepted_theta/iter_theta))
message(paste0("Acceptance rate on coins: ", paste(accepted_coin/iter_coin,collapse=" ")))
return(list(liks, chain, coin_chain))
}
library(reshape2)
library(plyr)
library(ggplot2)
print(paste0("Coin probs: ", paste0(signif(coin_probs,3),collapse=" ")))
print(paste0("Data suggest coin values: ", paste0(data_suggested_coins,collapse=" ")))
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
fixed <- c(1,1,1,rep(0,n))
covMat <- diag(length(fixed[which(fixed==0)]))*0.01
iter <- 5000
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE),nrow=indivs)
pars
fixed
fixed <- c(0,1,1)
likelihood_group(pars, coin_reuslts, dat)
likelihood_group(pars, coin_results, dat)
pars
nrow(dat)
coin_results
n <- 10
indivs <- 10
coin_probs <- matrix(runif(n*indivs),nrow=indivs)
pars <- c(4, 0.3, 0.1)
parNames <- c("boost","sigma","error",paste0("coin.",1:n))
coin_results <- matrix(sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE)),nrow=indivs)
dim(coin_results)
coin_probs
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_indiv.R', echo=TRUE)
coin_probs1
coin_probs
coin_results
data_suggested_coins
coin_probs1
dat
head(chain)
head(res[[2]])
plot(coda::as.mcmc(res[[2]]))
fixed
head(coin_chain)
plot(coda::as.mcmC(coin_chain))
plot(coda::as.mcmc(coin_chain))
p1
p2
p3
res <- run_MCMC_group(pars, fixed, dat, start_coins,coin_probs, iter, covMat,thin=10)
iter <- 50000
res <- run_MCMC_group(pars, fixed, dat, start_coins,coin_probs, iter, covMat,thin=10)
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_indiv.R', echo=TRUE)
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_model_indiv.R', echo=TRUE)
p1
head(res[[2]])
source("model_funcs.R")
source("probability_funcs.R")
source("proposal_funcs.R")
source("mcmc_funcs.R")
source('~/Documents/Fluscape/serosolver/scripts/testing/coin_toss/coin_model.R', echo=TRUE)
library(reshape2)
library(plyr)
library(ggplot2)
source("model_funcs.R")
source("probability_funcs.R")
setwd("~/Documents/Fluscape/serosolver/scripts/testing/coin_toss")
library(reshape2)
library(plyr)
library(ggplot2)
source("model_funcs.R")
source("probability_funcs.R")
source("proposal_funcs.R")
source("mcmc_funcs.R")
n <- 20
coin_probs <- runif(n)
indivs <- 10
pars <- c(4, 0.3, 1, coin_probs)
parNames <- c("boost","sigma","error",paste0("coin.",1:n))
coin_results <- sapply(coin_probs, function(x) sample(c(0,1),indivs,prob=c(1-x,x),replace=TRUE))
data_suggested_coins <- colSums(coin_results)/nrow(coin_results)
print(paste0("Coin probs: ", paste0(signif(coin_probs,3),collapse=" ")))
print(paste0("Data suggest coin values: ", paste0(data_suggested_coins,collapse=" ")))
dat <- coin_toss_group(pars, coin_results)
dat <- measurement_error_group(pars,dat)
fixed <- c(0,0,1,rep(0,n))
covMat <- diag(length(fixed[which(fixed==0)]))*0.01
iter <- 10000
start_coins <- matrix(sample(c(0,1),n*indivs,replace=TRUE),nrow=indivs)
res <- run_MCMC_group(pars, fixed, dat, start_coins,iter, covMat,thin=10, samps)
samps <- seq(1,n, by=2)
res <- run_MCMC_group(pars, fixed, dat, start_coins,iter, covMat,thin=10, samps)
warnings()
startPars <- pars
startPars <- rnorm(pars, 1, sd = 1)
startPars
chain <- res[[2]]
chain <- chain[,c(1,which(fixed == 0)+1)]
colnames(chain) <- c("sampno",parNames[which(fixed==0)])
plot(coda::as.mcmc(chain))
install.packages("MCMCvis")
require(MCMCvis)
data(MCMC_data)
summary(MCMC_data)
head(MCMC_data)
class(MCMC_data)

/* Dependent on titre of infecting strain at time of boost */
/* Go through by infection number */
NumericVector monitoredTitres(max_infections);
double monitoredTitre = 0;
double short_boost = 0;
double long_boost = 0;

for(int i = 0; i < max_infections; ++i){
  circulation_time = infectionTimes[i];
  monitoredTitre = 0;
  // Need to find titre of infecting strain at time of this infection,
  // so need to sum boosts of all previous infections
  for(int ii = i-1; ii >= 0; --ii){
    // How much boosting experienced from this infection?
    long_boost = maskedInfectionHistory[ii]* // Ignore infections that couldn't have happened
      MAX(0, 1.0 - tau*(cumInfectionHistory[ii] - 1.0))* // Antigenic seniority
      (mu*antigenicMapLong[measurementMapIndices[i]*numberStrains+infectionMapIndices[ii]]);
    
    // Short term cross reactive boost
    short_boost =  maskedInfectionHistory[ii]* // Ignore infections that couldn't have happened
      MAX(0, 1.0 - tau*(cumInfectionHistory[ii] - 1.0))* // Antigenic seniority
      (mu_short*antigenicMapShort[measurementMapIndices[i]*numberStrains+infectionMapIndices[ii]]);
    
    if(monitoredTitres[ii] >= boost_limit){
      long_boost =  long_boost*(1-gradient*boost_limit); // Titre dependent boosting - at ceiling
      short_boost =  short_boost*(1-gradient*boost_limit); // Titre dependent boosting - at ceiling
    } else {
      long_boost = long_boost*(1-gradient*monitoredTitres[ii]); // Titre dependent boosting - below ceiling
      short_boost = short_boost*(1-gradient*monitoredTitres[ii]); // Titre dependent boosting - below ceiling
    }
    long_boost = MAX(0, long_boost);
    short_boost = MAX(0, short_boost);
    boost = long_boost + short_boost*MAX(0, 1.0-wane*(circulation_time - infectionTimes[ii]));
    monitoredTitre += boost;
  }
  monitoredTitres[i] = monitoredTitre;

  // And now that we know the titre of the infecting strain at time of infection,
  // can work out the boost given to each measured strain from this infection
  for(int k = 0; k < n_samples; ++k){
     // How much boosting experienced from this infection?
    long_boost = maskedInfectionHistory[i]* // Ignore infections that couldn't have happened
      MAX(0, 1.0 - tau*(cumInfectionHistory[i] - 1.0))* // Antigenic seniority
      (mu*antigenicMapLong[measurementMapIndices[k]*numberStrains+infectionMapIndices[i]]);
    
    // Short term cross reactive boost
    short_boost =  maskedInfectionHistory[i]* // Ignore infections that couldn't have happened
      MAX(0, 1.0 - tau*(cumInfectionHistory[i] - 1.0))* // Antigenic seniority
      (mu_short*antigenicMapShort[measurementMapIndices[k]*numberStrains+infectionMapIndices[i]]);
    
    if(monitoredTitres[i] >= boost_limit){
      long_boost =  long_boost*(1-gradient*boost_limit); // Titre dependent boosting - at ceiling
      short_boost =  short_boost*(1-gradient*boost_limit); // Titre dependent boosting - at ceiling
    } else {
      long_boost = long_boost*(1-gradient*monitoredTitres[i]); // Titre dependent boosting - below ceiling
      short_boost = short_boost*(1-gradient*monitoredTitres[i]); // Titre dependent boosting - below ceiling
    }
    long_boost = MAX(0, long_boost);
    short_boost = MAX(0, short_boost);
    boost = long_boost + short_boost*waning[i];
    predictedTitre[k] += boost;
  }
 }

/* Dependent on titre of strain being boosted */
/* Go through strain by strain */
// For each strain we are testing against, find predicted titre
for(int k=0; k < n_samples; ++k){
  tmpTitre=0;
  monitoredTitre=0; // Keep track of the titre at the time of infection
  monitoredTitre_long=0; // How much boosting is adding up from the long term arm?

  // Sum contributions from all infections
  // Note that measurementMapIndices[k] finds the correct entry in the
  // antigenicMap vector for the *tested* strain (row), whereas
  // infectionMapIndices[i] finds the entry for the *infecting* strain (column)
  for(int i=0; i < max_infections; ++i){
    // Work out titre at the time of infection
    monitoredTitre = monitoredTitre_long; // Full long term boosts will apply
    // Go through each previous infection and work out amount of short-term
    // boosting that remains
    circulation_time = infectionTimes[i];
    for(int ii = i-1; ii >= 0; --ii){
      last_circulation_time = infectionTimes[ii];
      monitoredTitre += short_term_boosts[ii]*MAX(0, 1.0-wane*(circulation_time - last_circulation_time));
    }

    // How much boosting experienced from this infection?
    long_boost = maskedInfectionHistory[i]* // Ignore infections that couldn't have happened
      MAX(0, 1.0 - tau*(cumInfectionHistory[i] - 1.0))* // Antigenic seniority
      (mu*antigenicMapLong[measurementMapIndices[k]*numberStrains+infectionMapIndices[i]]);
	
    // Short term cross reactive boost
    short_boost =  maskedInfectionHistory[i]* // Ignore infections that couldn't have happened
      MAX(0, 1.0 - tau*(cumInfectionHistory[i] - 1.0))* // Antigenic seniority
      (mu_short*antigenicMapShort[measurementMapIndices[k]*numberStrains+infectionMapIndices[i]]);

    // ==============================================
    // Apply titre dependent suppression of boosting to short and long term arms
    if(gradient < 0) gradient = 0;
    if(monitoredTitre >= boost_limit){
      long_boost =  long_boost*(1-gradient*boost_limit); // Titre dependent boosting - at ceiling
      short_boost =  short_boost*(1-gradient*boost_limit); // Titre dependent boosting - at ceiling
    } else {
      long_boost = long_boost*(1-gradient*monitoredTitre); // Titre dependent boosting - below ceiling
      short_boost = short_boost*(1-gradient*monitoredTitre); // Titre dependent boosting - below ceiling
    }
    long_boost = MAX(0, long_boost);
    short_boost = MAX(0, short_boost);

    // Store amount of short-term boosting experienced without waning
    short_term_boosts[i] = short_boost;

    // All long term boosts add up
    monitoredTitre_long += long_boost;
	
    // Apply waning to time between sample taken and this infection
    boost = long_boost + waning[i]*short_boost;
    tmpTitre += boost;
  }
  // Total titre for strain k at this time
  predictedTitre[k] = tmpTitre;
 }
